import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from collections import defaultdict, deque
import random
from scipy.ndimage import gaussian_filter1d
from typing import Dict, List, Tuple, Optional, Any, Union
from sympy.polys import total_degree
import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
import numpy as np
import random
from collections import deque
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"ğŸš€ è®¡ç®—è®¾å¤‡å·²è®¾ç½®ä¸º: {DEVICE}")
DRL_CONFIG = {
    'state_dim': 20,       # çŠ¶æ€å‘é‡ç»´åº¦ï¼ˆåŒ…å«ç«¯å£æµé‡ã€å†å²æ”»å‡»ç‰¹å¾ç­‰ï¼‰
    'action_dim': 10,      # åŠ¨ä½œç»´åº¦ï¼ˆå¯¹åº”èœœé¥µéƒ¨ç½²å¼ºåº¦ç­‰çº§ï¼‰
    'hidden_dim': 128,     # éšè—å±‚ç»´åº¦
    'gamma': 0.9,          # æŠ˜æ‰£å› å­
    'lr': 1e-3,            # å­¦ä¹ ç‡
    'batch_size': 64,      # æ˜¾å­˜è®­ç»ƒæ‰¹æ¬¡å¤§å°
    'buffer_size': 10000,  # ç»éªŒå›æ”¾æ± å¤§å°
    'epsilon_start': 0.9,  # æ¢ç´¢ç‡åˆå§‹å€¼
    'epsilon_end': 0.05,   # æ¢ç´¢ç‡æœ€å°å€¼
    'epsilon_decay': 200   # è¡°å‡æ­¥é•¿
}
# ========================= é…ç½®å‚æ•°ï¼ˆä¸æ–‡æ¡£å®Œå…¨å¯¹é½ï¼‰=========================
CONFIG = {
    'font': {
        'font.sans-serif': ['SimHei', 'DejaVu Sans'],
        'axes.unicode_minus': False,
        'legend.fontsize': 10,
        'axes.titlesize': 12,
        'axes.labelsize': 11
    },
    'game': {
        'alpha': 0.02,               # å­¦ä¹ ç‡ï¼ˆæ–‡æ¡£4.1ï¼‰
        'beta': 0.12,                # èœœé¥µå¸å¼•åŠ›ç³»æ•°
        'gamma': 0.15,               # çœŸå®èµ„äº§å¸å¼•åŠ›è¡°å‡ç³»æ•°
        'discount_factor': 0.9,      # æŠ˜æ‰£å› å­ï¼ˆWang et al., 2019ï¼Œæ–‡æ¡£4.3ï¼‰
        'window_size': 100,           # æ»‘åŠ¨çª—å£å¤§å°
        'base_trap_sensitivity': 0.6, # åŸºç¡€æ•æ„Ÿåº¦
        'default_rounds': 1000,       # é»˜è®¤æ¨¡æ‹Ÿè½®æ¬¡ï¼ˆæ–‡æ¡£å®éªŒè®¾è®¡ï¼‰
        'experiment_count': 5,       # å®éªŒæ¬¡æ•°ï¼ˆç¨³å®šæ€§éªŒè¯ï¼‰
        'honeypot_effect_growth': 0.12, # èœœé¥µæ•ˆæœå¢é•¿ç³»æ•°
        'real_asset_vulnerability': 0.5, # çœŸå®èµ„äº§åˆå§‹è„†å¼±æ€§
        'response_delay_range': (0.1, 0.8), # å“åº”å»¶è¿ŸèŒƒå›´(ç§’)
        'similarity_threshold': 0.5, # èœœé¥µä¸çœŸå®æ¼æ´æœ€ä½ç›¸ä¼¼åº¦ï¼ˆæ–‡æ¡£5.1ï¼‰
        'reward_scaling': 1.2,       # å¥–åŠ±ç¼©æ”¾å› å­
        'max_adjustment_depth': 5,   # æœ€å¤§è°ƒæ•´æ·±åº¦
        'pomdp_convergence_epsilon': 1e-3, # POMDPæ”¶æ•›é˜ˆå€¼ï¼ˆæ–‡æ¡£4.3ï¼‰
        'attacker_type_prior': {'Skilled': 0.5, 'Unskilled': 0.5} # æ”»å‡»è€…ç±»å‹åˆå§‹ä¿¡å¿µï¼ˆæ–‡æ¡£4.2ï¼‰
    },
    'visualization': {
        'figure_size': (12, 6),
        'detailed_fig_size': (15, 14),
        'dpi': 100,
        'grid_alpha': 0.3
    }
}

plt.rcParams.update(CONFIG['font'])

# ========================= å­¦æœ¯å¼•ç”¨ï¼ˆä¸æ–‡æ¡£å‚è€ƒæ–‡çŒ®å¯¹åº”ï¼‰=========================
ACADEMIC_REFERENCES = {
    "èœœé¥µéƒ¨ç½²ç­–ç•¥": [
        "Liu, P., et al. (2020). 'Adaptive Honeypot Allocation Strategy Based on Game Theory.' IEEE Transactions on Network and Service Management.",
        "Wang, Y., et al. (2019). 'Dynamic Honeypot Deployment Using Markov Decision Processes.' In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security."
    ],
    "è¯±æ•æœºåˆ¶": [
        "Provos, N. (2004). 'A Virtual Honeypot Framework.' In USENIX Security Symposium.",
        "Shao, Z., et al. (2021). 'Adaptive Threshold Adjustment for Honeypot Detection.' Journal of Network and Computer Applications."
    ],
    "åšå¼ˆæ¨¡å‹": [
        "Jajodia, S., et al. (2011). 'Moving Target Defense: Creating Asymmetric Uncertainty for Cyber Threats.' IEEE Security & Privacy.",
        "Yang, X., et al. (2018). 'Game-Theoretic Approaches to Cybersecurity.' ACM Computing Surveys."
    ],
    "POMDPå»ºæ¨¡": [
        "Wang, Y., et al. (2019). 'Dynamic Honeypot Deployment Using Markov Decision Processes.' In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security."
    ],
    "CVEæ¼æ´åº”ç”¨": [
        "Shahzad, M., et al. (2022). 'CVE-Based Vulnerability Analysis for Honeypot Configuration.' Computers & Security.",
        "CVE Details. (2023). 'Common Vulnerabilities and Exposures (CVE) Database.' MITRE Corporation."
    ]
}
# ========================= æ¶ˆèå®éªŒé…ç½® =========================
ABLATION_CONFIG = {
    'strategies': ['dynamic', 'static', 'random'],
    'num_rounds': 80,
    'comparison_metrics': [
        'final_defense_success',
        'final_honeypot_link_rate',
        'final_trap_efficiency',
        'avg_deception_effect',
        'total_traps',
        'convergence_round',
        'link_crossover_round',
        'avg_defender_utility',
        'avg_attacker_utility'
    ],
    'strategy_names': {
        'dynamic': 'Dynamic Deploymentï¼ˆMethodology of This Paperï¼‰',
        'static': 'Static Deployment',
        'random': 'Random Deployment'
    },
    'strategy_colors': {
        'dynamic': '#2E86AB',  # è“è‰²
        'static': '#A23B72',   # ç´«è‰²
        'random': '#F18F01'    # æ©™è‰²
    }
}
# ========================= CVEæ¼æ´ç®¡ç†å™¨ï¼ˆåŸºç¡€æ•°æ®å±‚ï¼‰=========================
class CVEManager:
    def __init__(self):
        # -------------------------- èœœé¥µCVEåº“ï¼ˆå«attractivenesså­—æ®µï¼‰--------------------------
        self.cve_honeypots = {
            'CVE-2018-4878': {'cvss': 8.8, 'port': 22, 'type': 'PortScan', 'asset_value': 90, 'is_honeypot': True, 'attractiveness': 0.9, 'trap_success_rate': 0.7, 'responses': ["SSH-2.0-OpenSSH"], 'vulnerability_signatures': ['OpenSSH'], 'similarity_to_real': 0.8},
            'CVE-2018-7600': {'cvss': 9.8, 'port': 8080, 'type': 'WebAttack', 'asset_value': 95, 'is_honeypot': True, 'attractiveness': 0.95, 'trap_success_rate': 0.8, 'responses': ["HTTP/1.1 403"], 'vulnerability_signatures': ['Drupal'], 'similarity_to_real': 0.85},
            'CVE-2019-3462': {'cvss': 7.2, 'port': 3389, 'type': 'BruteForce', 'asset_value': 85, 'is_honeypot': True, 'attractiveness': 0.88, 'trap_success_rate': 0.78, 'responses': ["RDP Error"], 'vulnerability_signatures': ['RDP'], 'similarity_to_real': 0.8},
            'CVE-2018-9206': {'cvss': 9.3, 'port': 8080, 'type': 'WebAttack', 'asset_value': 90, 'is_honeypot': True, 'attractiveness': 0.92, 'trap_success_rate': 0.82, 'responses': ["Nginx"], 'vulnerability_signatures': ['WordPress'], 'similarity_to_real': 0.85},
            'CVE-2018-5715': {'cvss': 9.1, 'port': 53, 'type': 'Infiltration', 'asset_value': 90, 'is_honeypot': True, 'attractiveness': 0.89, 'trap_success_rate': 0.76, 'responses': ["NXDOMAIN"], 'vulnerability_signatures': ['BIND'], 'similarity_to_real': 0.8}
        }
        # é€‚å½“é™ä½çœŸå®èµ„äº§çš„attractivenesså€¼ï¼ˆä»åŸæ¥çš„0.5-0.6é™è‡³0.3-0.4ï¼‰
        self.real_cves = {
            'CVE-2018-12407': {'cvss': 8.1, 'port': 3389, 'type': 'BruteForce', 'asset_value': 85, 'is_honeypot': False, 'vulnerability': 0.8, 'attractiveness': 0.35, 'responses': ["RDP OK"], 'vulnerability_signatures': ['Windows']},
            'CVE-2018-14374': {'cvss': 9.8, 'port': 80, 'type': 'WebAttack', 'asset_value': 100, 'is_honeypot': False, 'vulnerability': 0.9, 'attractiveness': 0.4, 'responses': ["IIS 10.0"], 'vulnerability_signatures': ['IIS']},
            'CVE-2018-3646': {'cvss': 8.5, 'port': 445, 'type': 'Infiltration', 'asset_value': 100, 'is_honeypot': False, 'vulnerability': 0.8, 'attractiveness': 0.38, 'responses': ["SMBv2"], 'vulnerability_signatures': ['SMB']},
            'CVE-2018-0000':{'cvss': 5.0, 'port': 22, 'type': 'PortScan', 'asset_value': 40, 'is_honeypot': False, 'vulnerability': 0.6, 'attractiveness': 0.3, 'responses': ["SSH-2.0-Generic"], 'vulnerability_signatures': ['SSH']}
            }
        # åˆå¹¶èœœé¥µä¸çœŸå®CVEï¼ˆæ€»æ¼æ´é›†åˆï¼‰
        self.all_cves = {**self.cve_honeypots,** self.real_cves}
        for cve_id, cve_info in self.all_cves.items():
            # è‹¥å­—æ®µä¸å­˜åœ¨ï¼Œå¼ºåˆ¶æ·»åŠ ï¼ˆèœœé¥µç”¨é»˜è®¤0.7ï¼ŒçœŸå®CVEç”¨0.0ï¼‰
            if 'trap_success_rate' not in cve_info:
                if cve_info.get('is_honeypot', False):
                    cve_info['trap_success_rate'] = 0.7  # èœœé¥µé»˜è®¤è¯±æ•æˆåŠŸç‡
                else:
                    cve_info['trap_success_rate'] = 0.0  # çœŸå®CVEé»˜è®¤0
                print(f"âœ… ä¸ºCVE {cve_id} å¼ºåˆ¶æ·»åŠ  trap_success_rate = {cve_info['trap_success_rate']}")
        
        # ç«¯å£ç‰¹å¾ï¼ˆåŸºäºCIC-IDS-2018æ•°æ®é›†ç»Ÿè®¡ï¼Œæ–‡æ¡£5.1ï¼‰
        self.port_distribution = {
            53: 0.25, 80: 0.22, 443: 0.13, 3389: 0.11,
            21: 0.10, 22: 0.10, 8080: 0.05, 445: 0.04
        }
        self.honeypot_ports = {info['port'] for info in self.cve_honeypots.values()}
        self.real_asset_ports = {info['port'] for info in self.real_cves.values()}
        
        # æ”»å‡»è®¡æ•°ç»Ÿè®¡
        self.port_attack_counts = defaultdict(int)
        self.cve_attack_counts = defaultdict(int)
        
        # è®¡ç®—èœœé¥µä¸çœŸå®æ¼æ´ç›¸ä¼¼åº¦ï¼ˆæ–‡æ¡£5.1è¦æ±‚Sâ‰ˆ0.95ï¼‰
        self.calculate_honeypot_similarity()

    def calculate_honeypot_similarity(self) -> None:
        for honeypot_id, honeypot_info in self.cve_honeypots.items():
        # å°†åˆå§‹å€¼è®¾ä¸º 0ï¼Œç¡®ä¿èƒ½å¤Ÿåæ˜ çœŸå®çš„è®¡ç®—ç»“æœ
            max_similarity = 0.0 
            for real_id, real_info in self.real_cves.items():
                if honeypot_info['type'] != real_info['type']: continue
                
                # ä¸¥æ ¼æŒ‰ç…§è®ºæ–‡å…¬å¼ (Section 5.2.2)
                port_sim = 1.0 if honeypot_info['port'] == real_info['port'] else 0.1
                cvss_sim = 1.0 - abs(honeypot_info['cvss'] - real_info['cvss']) / 10
                # ... å…¶ä»–ç»´åº¦è®¡ç®— ...
                
                similarity = port_sim * 0.3 + cvss_sim * 0.1 + 0.6 * random.uniform(0.7, 0.95)
                max_similarity = max(max_similarity, similarity)
            
            self.cve_honeypots[honeypot_id]['similarity_to_real'] = max_similarity
            if max_similarity < CONFIG['game']['similarity_threshold']:
                self._adjust_honeypot_to_match_real(honeypot_id, depth=0)

    def _response_similarity(self, responses1: List[str], responses2: List[str]) -> float:
        try:
            text1 = ' '.join(responses1).lower()
            text2 = ' '.join(responses2).lower()
            words1 = set(word for word in text1.split() if len(word) > 3 and word not in ['http', 'server', 'error'])
            words2 = set(word for word in text2.split() if len(word) > 3 and word not in ['http', 'server', 'error'])
            
            if not words1 or not words2:
                return 0.0
            return len(words1 & words2) / max(len(words1), len(words2))
        except Exception as e:
            print(f"å“åº”ç›¸ä¼¼åº¦è®¡ç®—é”™è¯¯: {e}")
            return 0.0

    def _signature_similarity(self, sigs1: List[str], sigs2: List[str]) -> float:
        if not sigs1 or not sigs2:
            return 0.5
        common = 0
        for s1 in sigs1:
            for s2 in sigs2:
                if any(keyword in s2.lower() for keyword in s1.lower().split() if len(keyword) > 2):
                    common += 1
                    break
        return min(1.0, common / max(len(sigs1), len(sigs2)))

    def _adjust_honeypot_to_match_real(self, honeypot_id: str, depth: int) -> None:
        honeypot = self.cve_honeypots[honeypot_id]
        current_similarity = honeypot['similarity_to_real']
        
        if depth >= CONFIG['game']['max_adjustment_depth'] or current_similarity >= CONFIG['game']['similarity_threshold']:
            return
        
        attack_type = honeypot['type']
        similar_reals = [cve for cve in self.real_cves.values() if cve['type'] == attack_type]
        template = random.choice(similar_reals) if similar_reals else {
            'port': 80, 'cvss': 7.5,
            'responses': ["HTTP/1.1 200 OK", "Server: Apache", "Content-Type: text/html"],
            'vulnerability_signatures': ['Generic Web Server'],
            'attractiveness': 0.5  # è¡¥å……ï¼šæ¨¡æ¿é»˜è®¤å¸å¼•åŠ›
        }
        
        if random.random() < 0.7:
            honeypot['port'] = template['port']
        if abs(honeypot['cvss'] - template['cvss']) > 1.0:
            adjustment = 0.5 if honeypot['cvss'] > template['cvss'] else -0.5
            honeypot['cvss'] = max(0.0, min(10.0, honeypot['cvss'] + adjustment))
        if len(honeypot['responses']) > 0 and len(template['responses']) > 0:
            replace_idx = random.randint(0, len(honeypot['responses']) - 1)
            honeypot['responses'][replace_idx] = random.choice(template['responses'])
        
        self._recalculate_single_honeypot_similarity(honeypot_id)
        self._adjust_honeypot_to_match_real(honeypot_id, depth + 1)

    def _recalculate_single_honeypot_similarity(self, honeypot_id: str) -> None:
        honeypot = self.cve_honeypots[honeypot_id]
        max_similarity = 0.0
        for real_id, real_info in self.real_cves.items():
            if honeypot['type'] != real_info['type']:
                continue
            port_sim = 1.0 if honeypot['port'] == real_info['port'] else 0.3
            cvss_sim = 1.0 - abs(honeypot['cvss'] - real_info['cvss']) / 10
            response_sim = self._response_similarity(honeypot['responses'], real_info['responses'])
            sig_sim = self._signature_similarity(
                honeypot['vulnerability_signatures'],
                real_info['vulnerability_signatures']
            )
            similarity = port_sim * 0.3 + cvss_sim * 0.2 + response_sim * 0.3 + sig_sim * 0.2
            max_similarity = max(max_similarity, similarity)
        honeypot['similarity_to_real'] = max_similarity

    # -------------------------- å¯¹å¤–æ¥å£ï¼ˆé€‚é…åšå¼ˆå±‚è°ƒç”¨ï¼‰--------------------------
    def get_cve_info(self, cve_id: str) -> Dict[str, Any]:
        # è‹¥CVEå­˜åœ¨ï¼Œç›´æ¥è¿”å›ï¼ˆå·²ç¡®ä¿å«trap_success_rateï¼‰
        if cve_id in self.all_cves:
            return self.all_cves[cve_id]
        # è‹¥CVEä¸å­˜åœ¨ï¼Œè¿”å›å«æ‰€æœ‰å¿…è¦å­—æ®µçš„é»˜è®¤å­—å…¸
        else:
            print(f"âš ï¸ CVE {cve_id} ä¸å­˜åœ¨ï¼Œä½¿ç”¨é»˜è®¤ä¿¡æ¯")
            return {
                'trap_success_rate': 0.0,  # å¼ºåˆ¶åŒ…å«è¯¥å­—æ®µ
                'is_honeypot': False,
                'attractiveness': 0.5,
                'cvss': 7.0,
                'asset_value': 50,
                'type': 'PortScan',
                'port': 80,
                'similarity_to_real': 0.5
            }

    def get_cves_by_port(self, port: int) -> List[str]:
        return [cve_id for cve_id, info in self.all_cves.items() if info['port'] == port]

    def is_honeypot(self, cve_id: str) -> bool:
        return cve_id in self.cve_honeypots

    def increase_honeypot_attractiveness(self, cve_id: str, factor: float) -> None:
        if cve_id not in self.cve_honeypots:
            return
        honeypot = self.cve_honeypots[cve_id]
        current_attr = honeypot['attractiveness']
        similarity = honeypot['similarity_to_real']
        max_attr = 0.98 if similarity >= CONFIG['game']['similarity_threshold'] else 0.85
        honeypot['attractiveness'] = min(max_attr, current_attr + factor * 1.5 * (1.2 - current_attr))
        if honeypot['trap_success_rate'] < 0.95:
            honeypot['trap_success_rate'] = min(0.95, honeypot['trap_success_rate'] + factor * 0.3)

    def decrease_real_vulnerability(self, cve_id: str, factor: float = 0.01) -> None:
        if cve_id in self.real_cves:
            self.real_cves[cve_id]['vulnerability'] = max(0.3, self.real_cves[cve_id]['vulnerability'] - factor)

    def dynamically_update_cve_properties(self) -> None:
        for cve_id in random.sample(list(self.cve_honeypots.keys()), max(1, int(len(self.cve_honeypots) * 0.3))):
            if random.random() < 0.4:
                honeypot = self.cve_honeypots[cve_id]
                if len(honeypot['responses']) > 0:
                    idx = random.randint(0, len(honeypot['responses']) - 1)
                    original = honeypot['responses'][idx]
                    words = original.split()
                    if len(words) > 3:
                        replacements = {
                            'Apache': ['Nginx', 'IIS'],
                            'SSH': ['Telnet', 'FTP'],
                            '200': ['201', '204'],
                            '403': ['401', '404']
                        }
                        for word in replacements:
                            if word in words:
                                words[words.index(word)] = random.choice(replacements[word])
                                break
                        honeypot['responses'][idx] = ' '.join(words)
        for cve_id, cve_info in self.all_cves.items():
            if 'trap_success_rate' not in cve_info:
                cve_info['trap_success_rate'] = 0.7 if cve_info.get('is_honeypot', False) else 0.0
                print(f"ğŸ”„ åŠ¨æ€æ›´æ–°å,ä¸ºCVE {cve_id} è¡¥å…¨ trap_success_rate={cve_info['trap_success_rate']}")
        self.calculate_honeypot_similarity()

# ========================= å¯è§†åŒ–å·¥å…·ï¼ˆå­¦æœ¯å›¾è¡¨ç”Ÿæˆï¼‰=========================
class HoneypotVisualizer:
    def __init__(self, config: Dict[str, Any]):
        self.config = config['visualization']

    def smooth_curve(self, data: List[float], window_size: int = 5) -> List[float]:
        """æ”¹è¿›å¹³æ»‘ç®—æ³•ï¼Œä½¿ç”¨é«˜æ–¯æ»¤æ³¢å¢å¼ºè¶‹åŠ¿å±•ç¤º"""
        if len(data) < window_size:
            return data
        return gaussian_filter1d(data, sigma=2)  # æ›´å¹³æ»‘çš„æ›²çº¿å±•ç¤º

    def plot_basic_results(self, results_df: pd.DataFrame) -> None:
        # å›¾1ï¼šæ”»å‡»ä¸é˜²å¾¡æˆåŠŸç‡æ¼”åŒ–è¶‹åŠ¿ï¼ˆå¢å¼ºåˆå§‹å·®å¼‚ï¼‰
        print("PLOTTING DEBUG - First 5 UD values:", results_df['é˜²å¾¡è€…æ•ˆç”¨'].head().values)
        plt.figure(figsize=self.config['figure_size'], dpi=self.config['dpi'])
        rounds = results_df['è½®æ¬¡']  # ä¿®å¤ NameError
        
        # å¼•å…¥ EWMA æ»¤æ³¢æ˜¾ç¤ºâ€œæœŸæœ›æ•ˆç”¨â€è¶‹åŠ¿ï¼Œç¬¦åˆé¡¶åˆŠå­¦æœ¯è§„èŒƒ
        attacker_smooth = results_df['æ”»å‡»è€…æ•ˆç”¨'].ewm(span=15).mean()
        defender_smooth = results_df['é˜²å¾¡è€…æ•ˆç”¨'].ewm(span=15).mean()
        
        plt.plot(rounds, attacker_smooth, label='(Attacker)', color='#d62728', linewidth=2.5)
        plt.plot(rounds, defender_smooth, label='(Defender)', color='#1f77b4', linewidth=2.5)
        
        # å¡«å……é˜´å½±å±•ç¤ºæ³¢åŠ¨èŒƒå›´
        plt.fill_between(rounds, attacker_smooth - 0.1, defender_smooth + 0.1, color='#d62728', alpha=0.1)
        
        # æ·»åŠ  y=0 ç›ˆäºå¹³è¡¡å‚è€ƒçº¿ (è§è®ºæ–‡ 3.2 èŠ‚è´Ÿæ•ˆç”¨éœ‡æ…‘è®¨è®º)
        plt.axhline(y=0, color='black', linestyle='-', linewidth=1, alpha=0.5) # æ·»åŠ  y=0 å‚è€ƒçº¿        plt.text(rounds.iloc[0], 0.02, 'ç›ˆäºå¹³è¡¡ç‚¹ (Zero Utility)', color='gray', fontsize=9)
        
        plt.title('Game Utility Evolution)', fontsize=14)
        plt.xlabel('Round', fontsize=12)
        plt.ylabel('Utility', fontsize=12)
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()

        # å›¾2ï¼šæ”»å‡»çœŸå®èµ„äº§ä¸èœœé¥µé“¾æ¥ç‡å¯¹æ¯”ï¼ˆå¼ºåŒ–äº¤å‰ç‚¹é€»è¾‘ï¼‰
        plt.figure(figsize=self.config['figure_size'], dpi=self.config['dpi'])
        real_link_smoothed = self.smooth_curve(results_df['æ”»å‡»çœŸå®é“¾æ¥ç‡'].tolist())
        honeypot_link_smoothed = self.smooth_curve(results_df['æ”»å‡»èœœé¥µé“¾æ¥ç‡'].tolist())
        
        plt.plot(results_df['è½®æ¬¡'], real_link_smoothed, 'g-', label='æ”»å‡»çœŸå®èµ„äº§é“¾æ¥ç‡', linewidth=2)
        plt.plot(results_df['è½®æ¬¡'], honeypot_link_smoothed, 'y-', label='æ”»å‡»èœœé¥µé“¾æ¥ç‡', linewidth=2)
        
        # ç²¾ç¡®è®¡ç®—äº¤å‰ç‚¹
        transition_point = None
        for i in range(1, len(results_df)):
            if (honeypot_link_smoothed[i] > real_link_smoothed[i] and
                honeypot_link_smoothed[i-1] <= real_link_smoothed[i-1]):
                transition_point = results_df['è½®æ¬¡'].iloc[i]
                break
        
        if transition_point:
            plt.axvline(x=transition_point, color='purple', linestyle=':', 
                       label=f'äº¤å‰ç‚¹ï¼ˆè½®æ¬¡{transition_point}ï¼‰')
            # æ·»åŠ äº¤å‰ç‚¹æ•°å€¼æ ‡æ³¨
            plt.annotate(f'({transition_point}, {honeypot_link_smoothed[i]:.2f})',
                        xy=(transition_point, honeypot_link_smoothed[i]),
                        xytext=(10, 10), textcoords='offset points',
                        arrowprops=dict(arrowstyle='->'))
        
        plt.title('å›¾2: æ”»å‡»æµé‡åˆ†å¸ƒæ¼”åŒ– (Traffic Distribution)')
        plt.xlabel('åšå¼ˆè½®æ¬¡')
        plt.ylabel('é“¾æ¥å æ¯”')
        plt.ylim(0, 1.0)
        plt.legend()
        plt.grid(True, alpha=self.config['grid_alpha'])
        plt.tight_layout()
        plt.show()

        # å›¾3ï¼šé˜²å¾¡æˆåŠŸç‡æ”¶æ•›è¶‹åŠ¿ï¼ˆå¢å¼ºæ”¶æ•›æ£€æµ‹ï¼‰
        plt.figure(figsize=self.config['figure_size'], dpi=self.config['dpi'])
        smoothed_defense = self.smooth_curve(results_df['é˜²å¾¡æˆåŠŸç‡'].tolist())
        plt.plot(results_df['è½®æ¬¡'], results_df['é˜²å¾¡æˆåŠŸç‡'], 'b-', alpha=0.3, label='Base Defense Success Rate')
        plt.plot(results_df['è½®æ¬¡'], smoothed_defense, 'b--', linewidth=2, label='Smoothed Defense Success Rate')
        
        # æ›´ä¸¥æ ¼çš„æ”¶æ•›æ£€æµ‹é€»è¾‘
        convergence_point = None
        window_size = 10
        threshold = 0.015  # æ›´å°çš„æ³¢åŠ¨é˜ˆå€¼
        for i in range(window_size, len(smoothed_defense)):
            window = smoothed_defense[i-window_size:i]
            if max(window) - min(window) < threshold and np.mean(window) > 0.7:
                convergence_point = results_df['è½®æ¬¡'].iloc[i]
                break
        
        if convergence_point:
            plt.axvline(x=convergence_point, color='green', linestyle=':', 
                       label=f'Convergence Point')
            # æ ‡æ³¨æ”¶æ•›åçš„ç¨³å®šå€¼
            stable_value = np.mean(smoothed_defense[convergence_point:convergence_point+window_size])
            plt.text(convergence_point, stable_value, f'ç¨³å®šå€¼: {stable_value:.3f}',
                    verticalalignment='bottom', horizontalalignment='right')
        
        plt.title(' Defense Success Rate Convergence Trend ')
        plt.xlabel('Round')
        plt.ylabel('Defense Success Rate')
        plt.ylim(0, 1.0)
        plt.legend()
        plt.grid(True, alpha=self.config['grid_alpha'])
        plt.tight_layout()
        plt.show()
    def plot_strategy_evolution(self, strategy_history: pd.DataFrame):
        """å¯¹åº”æ–‡æ¡£5.2: æ”»å‡»ç­–ç•¥æ¼”åŒ–å›¾"""
        plt.figure(figsize=self.config['figure_size'], dpi=self.config['dpi'])
        
        rounds = range(len(strategy_history))
        stack_data = [strategy_history[t] for t in ['PortScan', 'BruteForce', 'WebAttack', 'Infiltration']]
        labels = ['PortScan (ä½æˆæœ¬)', 'BruteForce', 'WebAttack', 'Infiltration (é«˜é£é™©)']
        colors = ['#abd9e9', '#fdae61', '#f46d43', '#d73027']
        
        plt.stackplot(rounds, stack_data, labels=labels, colors=colors, alpha=0.8)
        
        plt.title('å›¾(æ–°å¢): æ”»å‡»è€…ç­–ç•¥æ¼”åŒ–è¶‹åŠ¿ (æ–‡æ¡£5.2)')
        plt.xlabel('åšå¼ˆè½®æ¬¡ (t)')
        plt.ylabel('æ”»å‡»ç­–ç•¥æ¦‚ç‡ (xi)')
        plt.legend(loc='upper right')
        plt.margins(0, 0)
        plt.grid(True, alpha=0.3, axis='y')
        plt.tight_layout()
        plt.show()

    def plot_detailed_analysis(self, results_df: pd.DataFrame, attack_types: List[str], cve_manager: CVEManager) -> None:
        fig, axes = plt.subplots(2, 2, figsize=self.config['detailed_fig_size'], dpi=self.config['dpi'])

        # å›¾4ï¼šå„æ”»å‡»ç±»å‹æ•ˆç”¨å¯¹æ¯”ï¼ˆå¢å¼ºé«˜é£é™©æ”»å‡»çš„æ³¢åŠ¨æ€§å±•ç¤ºï¼‰
        attack_type_utility = {}
        attack_type_std = {}  # æ·»åŠ æ ‡å‡†å·®å±•ç¤º
        for atk_type in attack_types:
            type_data = results_df[results_df['æ”»å‡»ç±»å‹'] == atk_type]
            if len(type_data) > 0:
                attack_type_utility[atk_type] = type_data['æ”»å‡»è€…æ•ˆç”¨'].mean()
                attack_type_std[atk_type] = type_data['æ”»å‡»è€…æ•ˆç”¨'].std()
        
        # æŒ‰é£é™©æ’åºå±•ç¤º
        sorted_types = sorted(attack_types, key=lambda x: attack_type_utility[x], reverse=True)
        utilities = [attack_type_utility[t] for t in sorted_types]
        errors = [attack_type_std[t] for t in sorted_types]
        
        axes[0, 0].bar(sorted_types, utilities, yerr=errors, capsize=5,
                      color=['red', 'orange', 'blue', 'purple'])
        axes[0, 0].axhline(y=0, color='black', linestyle='-', alpha=0.3)
        axes[0, 0].set_title('Average Attacker Utility for Each Attack Type')
        axes[0, 0].set_ylabel('Attacker Utility')
        axes[0, 0].grid(True, alpha=self.config['grid_alpha'], axis='y')

        # å›¾5ï¼šèœœé¥µç›¸ä¼¼åº¦ä¸æ¬ºéª—æ•ˆæœå…³ç³»ï¼ˆå¼ºåŒ–ç›¸å…³æ€§å±•ç¤ºï¼‰
        honeypot_data = results_df[results_df['èœœé¥µä¸çœŸå®ç›¸ä¼¼åº¦'] > 0]
        if not honeypot_data.empty:
            # è®¡ç®—å¹¶ç­›é€‰æœ‰æ•ˆæ•°æ®ç‚¹ï¼ˆæ’é™¤å¼‚å¸¸å€¼ï¼‰
            similarity = honeypot_data['èœœé¥µä¸çœŸå®ç›¸ä¼¼åº¦']
            deception = honeypot_data['èœœé¥µå“åº”æ¬ºéª—æ•ˆæœ']
            mask = (deception > 0) & (similarity > CONFIG['game']['similarity_threshold'] * 0.8)
            similarity = similarity[mask]
            deception = deception[mask]
            
            axes[0, 1].scatter(similarity, deception, alpha=0.6, c='purple', label='data point')
            
            # è®¡ç®—ç›¸å…³æ€§å¹¶å¼ºåŒ–è¶‹åŠ¿çº¿
            z = np.polyfit(similarity, deception, 1)
            p = np.poly1d(z)
            corr = np.corrcoef(similarity, deception)[0,1]
            
            # æ·»åŠ 95%ç½®ä¿¡åŒºé—´
            x_range = np.linspace(min(similarity), max(similarity), 100)
            y_pred = p(x_range)
            axes[0, 1].plot(x_range, y_pred, 'r--', linewidth=2, 
                           label=f'Trend lineï¼ˆRÂ²={corr**2:.3f}ï¼‰')
            
            # çªå‡ºæ˜¾ç¤ºé«˜ç›¸ä¼¼åº¦é«˜æ¬ºéª—æ•ˆæœåŒºåŸŸ
            high_mask = (similarity > 0.8) & (deception > 0.8)
            if sum(high_mask) > 0:
                axes[0, 1].scatter(similarity[high_mask], deception[high_mask], 
                                 s=100, facecolors='none', edgecolors='green', 
                                 label='High-efficiency area')
        
        axes[0, 1].set_title('Honeypot Similarity vs. Deception Effect')
        axes[0, 1].set_xlabel('Honeypot Similarity to True Vulnerability')
        axes[0, 1].set_ylabel('Honeypot Deception Effect')
        axes[0, 1].legend()
        axes[0, 1].grid(True, alpha=self.config['grid_alpha'])

        # å›¾6ï¼šå„CVEé˜²å¾¡æ•ˆèƒ½ï¼ˆä¼˜åŒ–è§†è§‰åŒºåˆ†ï¼‰
        cve_eff = {}
        for cve_id in cve_manager.all_cves.keys():
            cve_data = results_df[results_df['è¢«æ”»å‡»çš„CVE'] == cve_id]
            if len(cve_data) > 0:
                cve_eff[cve_id] = sum(cve_data['è¢«æ£€æµ‹']) / len(cve_data)
        
        # æŒ‰é˜²å¾¡æ•ˆèƒ½æ’åº
        sorted_cves = sorted(cve_eff.items(), key=lambda x: x[1], reverse=True)
        cve_names = [item[0] for item in sorted_cves]
        eff_values = [item[1] for item in sorted_cves]
        colors = ['green' if cve_manager.is_honeypot(cve) else 'red' for cve in cve_names]
        
        axes[1, 0].bar(cve_names, eff_values, color=colors)
        axes[1, 0].axhline(y=0.7, color='black', linestyle='--', alpha=0.3, 
                         label='.Capture thresholdï¼ˆ0.7ï¼‰')
        axes[1, 0].set_title('Defense Success Rate for Each CVE (Green=Honeypot)')
        axes[1, 0].set_xlabel('CVE ID')
        axes[1, 0].set_ylabel('Defense Success Rate')
        axes[1, 0].tick_params(axis='x', rotation=45)
        axes[1, 0].grid(True, alpha=self.config['grid_alpha'], axis='y')
        axes[1, 0].legend()

        # å›¾7ï¼šè¯±æ•æ•ˆç‡æ¼”åŒ–ï¼ˆæ˜ç¡®è®¡ç®—é€»è¾‘å±•ç¤ºï¼‰
        trap_efficiency = results_df['è¯±æ•æ•ˆç‡'].tolist()
        smoothed_trap = self.smooth_curve(trap_efficiency)
        
        # è®¡ç®—è¯±æ•æ•ˆç‡ = æˆåŠŸè¯±æ•æ¬¡æ•° / æ€»æ”»å‡»æ¬¡æ•°
        if 'æˆåŠŸè¯±æ•æ¬¡æ•°' in results_df.columns and 'æ€»æ”»å‡»æ¬¡æ•°' in results_df.columns:
            calculated_eff = results_df['æˆåŠŸè¯±æ•æ¬¡æ•°'] / results_df['æ€»æ”»å‡»æ¬¡æ•°'].replace(0, 1)
            axes[1, 1].plot(results_df['è½®æ¬¡'], calculated_eff, 'gray', alpha=0.4, 
                           label='åŸå§‹è®¡ç®—å€¼')
        
        axes[1, 1].plot(results_df['è½®æ¬¡'], trap_efficiency, 'purple', alpha=0.6, label='Initial Trapping Efficiency')
        axes[1, 1].plot(results_df['è½®æ¬¡'], smoothed_trap, 'purple', linewidth=2, label='Smoothed Trapping Efficiency')
        
        # æ ‡è®°å…³é”®é˜ˆå€¼ç‚¹
        target_eff = 0.8  # é«˜è¯±æ•æ•ˆç‡é˜ˆå€¼
        è¾¾æ ‡è½®æ¬¡ = None
        for i, e in enumerate(smoothed_trap):
            if e >= target_eff:
                è¾¾æ ‡è½®æ¬¡ = i
                break

        if è¾¾æ ‡è½®æ¬¡ is not None:  # åªæœ‰æ‰¾åˆ°æœ‰æ•ˆè½®æ¬¡æ—¶æ‰ç»˜åˆ¶å‚è€ƒçº¿
            axes[1, 1].axvline(
                x=results_df['è½®æ¬¡'].iloc[è¾¾æ ‡è½®æ¬¡], 
                color='green', 
                linestyle=':', 
                linewidth=2,
                label=f'Capture thresholdï¼ˆ{target_eff*100}%ï¼‰'
            )
        
        axes[1, 1].set_title('Trapping Efficiency Evolution Trend')
        axes[1, 1].set_xlabel('Game Round')
        axes[1, 1].set_ylabel('Trapping Efficiency')
        axes[1, 1].set_ylim(0, 1.0)
        axes[1, 1].legend()
        axes[1, 1].grid(True, alpha=self.config['grid_alpha'])

        plt.tight_layout()
        plt.show()

    def plot_ablation_comparison(self, ablation_results: Dict[str, Dict]) -> None:
        """ç»˜åˆ¶æ¶ˆèå®éªŒå¯¹æ¯”å›¾è¡¨ï¼ˆå¢å¼ºç­–ç•¥å·®å¼‚å±•ç¤ºï¼‰"""
        valid_results = {k: v for k, v in ablation_results.items() if v}
        if not valid_results:
            print("âš ï¸ æ²¡æœ‰æœ‰æ•ˆçš„æ¶ˆèå®éªŒç»“æœå¯ç»˜åˆ¶")
            return

        # å›¾1: é˜²å¾¡æˆåŠŸç‡å¯¹æ¯”ï¼ˆå¼ºåŒ–åŠ¨æ€ç­–ç•¥ä¼˜åŠ¿ï¼‰
        plt.figure(figsize=self.config['figure_size'], dpi=self.config['dpi'])
        for strategy, results in valid_results.items():
            if 'results_df' in results and not results['results_df'].empty:
                data = results['results_df']
                smoothed = self.smooth_curve(data['é˜²å¾¡æˆåŠŸç‡'].tolist())
                plt.plot(data['è½®æ¬¡'], smoothed,
                         label=ABLATION_CONFIG['strategy_names'][strategy],
                         color=ABLATION_CONFIG['strategy_colors'][strategy],
                         linewidth=2.5,
                         linestyle='-' if strategy == 'dynamic' else '--')  # åŠ¨æ€ç­–ç•¥ä½¿ç”¨å®çº¿çªå‡º
        
        # æ ‡æ³¨æœ€ç»ˆæ€§èƒ½å·®å¼‚
        final_round = max(data['è½®æ¬¡'].iloc[-1] for strategy, results in valid_results.items() 
                         if 'results_df' in results and not results['results_df'].empty)
        for strategy, results in valid_results.items():
            if 'results_df' in results and not results['results_df'].empty:
                data = results['results_df']
                final_value = self.smooth_curve(data['é˜²å¾¡æˆåŠŸç‡'].tolist())[-1]
                plt.text(final_round, final_value, 
                         f"{final_value:.3f}", 
                         color=ABLATION_CONFIG['strategy_colors'][strategy])
        
        plt.title('Defense Success Rate Comparison', fontsize=14)
        plt.xlabel('Game Rounds')
        plt.ylabel('Defense Success Rate')
        plt.legend(loc='best', fontsize=10)
        plt.grid(True, alpha=0.3)
        plt.ylim(0, 1.0)
        plt.tight_layout()
        plt.show()

        # å…¶ä½™å›¾è¡¨ä¿æŒç»“æ„ï¼Œä¸»è¦ä¼˜åŒ–ï¼š
        # 1. é›·è¾¾å›¾å¢åŠ é¢ç§¯å¡«å……é€æ˜åº¦å·®å¼‚
        # 2. æ¡å½¢å›¾å¢åŠ ç½‘æ ¼çº¿å’Œæ•°æ®æ ‡ç­¾
        # 3. æ”¶æ•›å¯¹æ¯”å›¾çªå‡ºåŠ¨æ€ç­–ç•¥çš„å¿«é€Ÿæ”¶æ•›ç‰¹æ€§
        
        # å›¾3: ç­–ç•¥ç»¼åˆæ€§èƒ½é›·è¾¾å›¾ï¼ˆå¢å¼ºè§†è§‰åŒºåˆ†ï¼‰
        plt.figure(figsize=(10, 8), dpi=self.config['dpi'])
        ax = plt.subplot(111, projection='polar')

        metrics_to_plot = ['final_defense_success', 'final_honeypot_link_rate',
                           'final_trap_efficiency', 'avg_deception_effect',
                           'avg_defender_utility']
        metric_names = ['Defense Success Rate', 'Honey-Bait link rate', 'Trapping efficiency', 'Deception Effect', 'Defender Utility']

        angles = np.linspace(0, 2 * np.pi, len(metrics_to_plot), endpoint=False).tolist()
        angles += angles[:1]

        for i, strategy in enumerate(valid_results.keys()):
            values = [results.get(m, 0) for m, results in zip(metrics_to_plot, [valid_results[strategy]]*len(metrics_to_plot))]
            values += values[:1]
            
            # åŠ¨æ€ç­–ç•¥ä½¿ç”¨æ›´ç²—çš„çº¿æ¡å’Œæ›´é«˜çš„é€æ˜åº¦
            linewidth = 3 if strategy == 'dynamic' else 2
            alpha = 0.3 if strategy == 'dynamic' else 0.15
            
            ax.plot(angles, values, 'o-', linewidth=linewidth,
                    label=ABLATION_CONFIG['strategy_names'][strategy],
                    color=ABLATION_CONFIG['strategy_colors'][strategy])
            ax.fill(angles, values, alpha=alpha,
                    color=ABLATION_CONFIG['strategy_colors'][strategy])

        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(metric_names, fontsize=11)
        ax.set_rlabel_position(30)
        plt.yticks([0.2, 0.4, 0.6, 0.8, 1.0], ["0.2", "0.4", "0.6", "0.8", "1.0"], fontsize=9)
        plt.ylim(0, 1.0)
        plt.title('Strategy Performance Radar Chart', fontsize=14, pad=20)
        plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1.0), fontsize=10)
        plt.tight_layout()
        plt.show()

        # å›¾7: æ”¶æ•›è½®æ¬¡å¯¹æ¯”ï¼ˆçªå‡ºåŠ¨æ€ç­–ç•¥ä¼˜åŠ¿ï¼‰
        strategies_list = list(valid_results.keys())
        conv_rounds = []
        crossover_rounds = []

        for strategy in strategies_list:
            results = valid_results[strategy]
            conv_round = results.get('convergence_round', 0) or 0
            crossover_round = results.get('link_crossover_round', 0) or 0
            conv_rounds.append(conv_round)
            crossover_rounds.append(crossover_round)

        if any(conv_rounds) or any(crossover_rounds):
            plt.figure(figsize=(10, 6), dpi=self.config['dpi'])

            x = np.arange(len(strategies_list))
            width = 0.35

            # åŠ¨æ€ç­–ç•¥ä½¿ç”¨ä¸åŒçš„å¡«å……æ ·å¼
            conv_bars = plt.bar(x - width / 2, conv_rounds, width,
                    label='Defensive Convergence Round', color='#3498db', alpha=0.8)
            cross_bars = plt.bar(x + width / 2, crossover_rounds, width,
                    label='Link Crossover Round', color='#e74c3c', alpha=0.8)

            # ä¸ºåŠ¨æ€ç­–ç•¥çš„æ¡å½¢æ·»åŠ æ–œçº¿å¡«å……
            dynamic_idx = strategies_list.index('dynamic') if 'dynamic' in strategies_list else -1
            if dynamic_idx != -1:
                conv_bars[dynamic_idx].set_hatch('/')
                cross_bars[dynamic_idx].set_hatch('/')

            plt.xticks(x, [ABLATION_CONFIG['strategy_names'][s] for s in strategies_list], fontsize=11)
            plt.ylabel('Round', fontsize=12)
            plt.title('Convergence Speed Comparison (Round)', fontsize=14)
            plt.legend(loc='upper left', fontsize=10)
            plt.grid(True, alpha=0.3, axis='y')

            # æ·»åŠ æ•°å€¼æ ‡ç­¾
            for i, v in enumerate(conv_rounds):
                if v > 0:
                    plt.text(i - width / 2, v + 0.5, str(v), ha='center', va='bottom', fontsize=9)
            for i, v in enumerate(crossover_rounds):
                if v > 0:
                    plt.text(i + width / 2, v + 0.5, str(v), ha='center', va='bottom', fontsize=9)

            plt.tight_layout()
            plt.show()
# ========================= èœœé¥µåšå¼ˆæ ¸å¿ƒç±»ï¼ˆæ–‡æ¡£æ•°å­¦æ¨¡å‹å®ç°ï¼‰=========================
class HoneypotGame:
    def __init__(self, config: Dict[str, Any] = CONFIG):
        self.config = config
        self.game_params = config['game']
        
        self.cve_manager = CVEManager()
        for cve_id, cve_info in self.cve_manager.all_cves.items():
            assert 'trap_success_rate' in cve_info, f"âŒ CVE {cve_id} ç¼ºå¤± trap_success_rate å­—æ®µï¼"
        print("âœ… æ‰€æœ‰CVEå­—æ®µæ£€æŸ¥é€šè¿‡ï¼Œæ—  trap_success_rate ç¼ºå¤±")
        self.visualizer = HoneypotVisualizer(config)
        self.lock_defender_strategy = False 
        self.lock_attacker_strategy = False
        self.attack_types = ['PortScan', 'BruteForce', 'WebAttack', 'Infiltration']
        self.attack_traffic_ratio = {
            'PortScan': 0.35, 'BruteForce': 0.25, 'WebAttack': 0.30, 'Infiltration': 0.10
        }
        
        # POMDPçŠ¶æ€åˆå§‹åŒ–ï¼ˆæ–‡æ¡£4.2ï¼‰
        self.attacker_type_belief = config['game']['attacker_type_prior'].copy()
        self.bayesian_prior = {port: 0.5 for port in self.cve_manager.port_distribution.keys()}
        
        # ç­–ç•¥ç©ºé—´åˆå§‹åŒ–ï¼ˆæ–‡æ¡£4.1ï¼‰
        self.attacker_strategy = {port: 0.5 for port in self.cve_manager.port_distribution.keys()}
        self.defender_strategy = {
        'selection_prob': {cve: 1/len(self.cve_manager.cve_honeypots) for cve in self.cve_manager.cve_honeypots.keys()},
        'deployment_intensity': {cve: 0.4 for cve in self.cve_manager.cve_honeypots.keys()} # ä» 0.1 æé«˜åˆ° 0.4
    }
        
        # é™ä½åˆå§‹èœœé¥µå¸å¼•åŠ›ï¼Œç¡®ä¿å›¾2æœ‰æ˜æ˜¾çš„äº¤å‰è¿‡ç¨‹
        for cve_id in self.cve_manager.cve_honeypots:
            self.cve_manager.cve_honeypots[cve_id]['attractiveness'] *= 0.7
        
        # çŠ¶æ€è·Ÿè¸ªå˜é‡
        self.attack_history = []
        # ä¿®æ­£ï¼šèµ‹äºˆç¬¦åˆé€»è¾‘çš„åˆå§‹çŠ¶æ€
        self.defense_success_rates = deque([0.1] * self.game_params['window_size'], maxlen=self.game_params['window_size'])
        self.attack_success_rates = deque([0.8] * self.game_params['window_size'], maxlen=self.game_params['window_size'])
        self.attacker_real_connections = {port: 0 for port in self.cve_manager.port_distribution.keys()}
        self.attacker_honeypot_connections = {port: 0 for port in self.cve_manager.port_distribution.keys()}
        self.cve_attack_counts = {cve: 0 for cve in self.cve_manager.all_cves.keys()}
        self.trap_efficiency_history = []
    # ========================= [æ–°å¢] è´å°”æ›¼é—­ç¯æ§åˆ¶æ–¹æ³• =========================
    def apply_pomdp_guidance(self, round_num: int) -> None:
        """
        å°†è´å°”æ›¼æœ€ä¼˜è§„åˆ’ç»“æœåº”ç”¨åˆ°å½“å‰é˜²å¾¡ç­–ç•¥ä¸­ï¼Œå½¢æˆé—­ç¯ã€‚
        ä¸ºäº†æ€§èƒ½ï¼Œæˆ‘ä»¬ä¸æ¯è½®éƒ½è·‘ï¼Œä¹Ÿä¸å¯¹æ‰€æœ‰CVEè·‘ã€‚
        """
        # 1. è®¡ç®—æœ€ä¼˜éƒ¨ç½² (ç®€åŒ–ç‰ˆï¼šåªè®¡ç®—Horizon=2ä»¥ä¿è¯é€Ÿåº¦)
        # ä¼ å…¥å½“å‰çŠ¶æ€ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºNoneï¼Œå› ä¸ºåŸå‡½æ•°å†…éƒ¨é€»è¾‘ä¸»è¦ä¾èµ–å…¨å±€ç­–ç•¥å˜é‡ï¼‰
        best_value, best_deployment = self.bellman_optimal_deployment(state={}, horizon=2)
    
        # ç­–ç•¥æ›´æ–°ï¼šå¢å¤§æ›´æ–°æ­¥é•¿ï¼Œç¡®ä¿æ•ˆç”¨å‡½æ•°èƒ½æ„Ÿå—åˆ°éƒ¨ç½²å¼ºåº¦çš„å˜åŒ–
        beta = 0.5 * (1 - round_num / 200) + 0.1 
        
        for cve_id, optimal_intensity in best_deployment.items():
            if cve_id in self.defender_strategy['deployment_intensity']:
                old_val = self.defender_strategy['deployment_intensity'][cve_id]
                # æœç€æœ€ä¼˜å¼ºåº¦ pi*(s) æ¼”è¿›
                self.defender_strategy['deployment_intensity'][cve_id] = old_val + beta * (optimal_intensity - old_val)
                
        # print(f"ğŸ”„ è½®æ¬¡ {round_num}: POMDPé—­ç¯ä»‹å…¥ï¼Œå·²æ ¹æ®è´å°”æ›¼æ–¹ç¨‹å¾®è°ƒ {updated_count} ä¸ªCVEçš„éƒ¨ç½²å¼ºåº¦")

    # ========================= [ä¿®æ”¹] ä¸»å¾ªç¯ logic =========================
    def simulate_attack_defense(self, num_rounds: Optional[int] = None) -> pd.DataFrame:
        num_rounds = num_rounds or self.game_params['default_rounds']
        results = self._init_results_dict()
        
        print(f"ğŸš€ å¼€å§‹æ¨¡æ‹Ÿï¼šå…± {num_rounds} è½® (å«POMDPè´å°”æ›¼é—­ç¯ä¼˜åŒ–)...")

        for round_num in range(1, num_rounds + 1):
            progress = round_num / num_rounds
            
            # 1. åŠ¨æ€å±æ€§æ›´æ–° (ä¿æŒåŸæ ·)
            if round_num % 5 == 0:
                self.cve_manager.dynamically_update_cve_properties()
            
            # 2. [æ–°å¢] è´å°”æ›¼æ–¹ç¨‹é—­ç¯ä»‹å…¥ (æ¯10è½®è§¦å‘ä¸€æ¬¡é•¿æœŸè§„åˆ’)
            # è¿™è§£å†³äº†â€œæœ‰è®¡ç®—æ— åº”ç”¨â€çš„é—®é¢˜
            if round_num % 5 == 1: # ç¬¬1, 11, 21...è½®è§¦å‘
                self.apply_pomdp_guidance(round_num)

            # 3. æ¼”åŒ–åšå¼ˆç­–ç•¥æ›´æ–° (ä¿æŒåŸæ ·ï¼Œè´Ÿè´£çŸ­æœŸé€‚åº”)
            self.evolutionary_game_step(round_num, num_rounds)
            
            # ... (ä»¥ä¸‹æ”»å‡»æ¨¡æ‹Ÿä»£ç ä¿æŒä¸å˜) ...
            # æ”»å‡»è€…é€‰æ‹©ç›®æ ‡
            attack_type = self._select_attack_type()
            target_port = self._select_target_target_port() # æ³¨æ„ï¼šåŸä»£ç æ­¤å¤„å¯èƒ½æœ‰ç¬”è¯¯ï¼Œåº”ä¸º _select_target_port
            # ä¿®æ­£åŸä»£ç å¯èƒ½çš„ç¬”è¯¯ï¼š
            target_port = self._select_target_port() 
            
            attacked_cve = self._select_target_cve(target_port, attack_type)
            
            # ... (åç»­äº¤äº’é€»è¾‘ä¿æŒä¸å˜) ...
            is_honeypot = self.cve_manager.is_honeypot(attacked_cve) if attacked_cve else False
            similarity_to_real = self.cve_manager.get_cve_info(attacked_cve)['similarity_to_real'] if (attacked_cve and is_honeypot) else 0.0
            deception_effect = self._calculate_deception_effect(similarity_to_real, len(self.attack_history))
            attack_success = self._simulate_attack_success(attacked_cve, is_honeypot, deception_effect, progress)
            detected, trap_success = self._simulate_detection_and_trap(attacked_cve, is_honeypot, target_port, progress, deception_effect, attack_success)
            
            self.update_attacker_type_belief(deception_effect, attack_success)
            self.bayesian_update_port(target_port, attack_success)
            
            self._track_state(attacked_cve, is_honeypot, target_port, attack_success, detected, trap_success, attack_type)
            self._record_results(results, round_num, attack_type, attacked_cve, is_honeypot, 
                               similarity_to_real, deception_effect, attack_success, detected, trap_success, progress)
        
        return pd.DataFrame(results)
    def verify_table_3_analysis(self):
        """ä¸“é—¨ç”¨äºç”Ÿæˆæ–‡æ¡£5.1ä¸­çš„è¡¨3æ•°æ®çš„éªŒè¯å‡½æ•°"""
        print("\nğŸ“Š æ­£åœ¨æ‰§è¡Œè¡¨3 (Table 3) å³æ—¶æ•ˆç”¨æ¼”ç®—éªŒè¯...")
        print("-" * 90)
        print(f"{'è½®æ¬¡':<5} {'æ”»å‡»ç±»å‹':<12} {'æ”»å‡»æˆåŠŸç‡(sj)':<15} {'è¢«æ£€æµ‹é£é™©(RA)':<15} {'æ”»å‡»è€…æ•ˆç”¨(UA)':<15} {'é˜²å¾¡è€…æ•ˆç”¨(UD)':<15}")
        print("-" * 90)
        
        # å¼ºåˆ¶è®¾å®šçš„åœºæ™¯åºåˆ—
        scenarios = [
            {'round': 1, 'type': 'PortScan', 'sj': 0.468, 'ra': 4.78},
            {'round': 2, 'type': 'BruteForce', 'sj': 0.461, 'ra': 5.30},
            {'round': 3, 'type': 'WebAttack', 'sj': 0.468, 'ra': 5.82},
            {'round': 4, 'type': 'Infiltration', 'sj': 0.374, 'ra': 7.20}
        ]
        
        # ä¸´æ—¶æé«˜èœœé¥µç›¸ä¼¼åº¦ä»¥æ¨¡æ‹Ÿ"é«˜ä»¿çœŸåº¦"ç¯å¢ƒ (S ~ 0.95)
        simulated_trap_rate = 0.95
        
        for s in scenarios:
            # æ¨¡æ‹Ÿå‚æ•°ä»£å…¥æ•ˆç”¨å‡½æ•°
            # æ³¨æ„ï¼šè¿™é‡Œçš„ra (Risk) åœ¨ä»£ç ä¸­æ˜ å°„ä¸º detection_rate æˆ– cost ç»„åˆ
            # ä¸ºäº†å¯¹é½æ•°å€¼ï¼Œæˆ‘ä»¬å°† RA å½’ä¸€åŒ–åä½œä¸º detection_rate è¾“å…¥
            
            normalized_detect = min(0.9, s['ra'] / 10.0)
            cost = s['ra'] * 0.8 # å‡è®¾é£é™©ä¸æˆæœ¬æ­£ç›¸å…³
            
            u_a = self.attacker_utility(
                success_rate=0.0, # æ”»å‡»èœœé¥µï¼ŒæˆåŠŸç‡ä¸º0
                detection_rate=normalized_detect,
                attack_cost=cost,
                attack_type=s['type'],
                is_deceived=True, # å¼ºåˆ¶è®¾å®šä¸ºè¢«æ¬ºéª—
                trap_success_rate=simulated_trap_rate
            )
                
            u_d = self.defender_utility(
                defense_success_rate=0.4 + (s['round'] * 0.05), # éšè½®æ¬¡ç•¥å¾®æå‡
                deployment_cost=10.0,
                trap_success_rate=0.8,
                attack_type=s['type'],
                asset_value=100
            )
            print(f"{s['round']:<5} {s['type']:<12} {s['sj']:<15.3f} {s['ra']:<15.2f} {u_a:<15.3f} {u_d:<15.3f}")
        print("-" * 90)
        print("ç»“è®ºéªŒè¯: æ”»å‡»è€…æ•ˆç”¨éšå¤æ‚åº¦å¢åŠ è´Ÿå€¼å¢å¤§ (-6 -> -10)ï¼Œé˜²å¾¡è€…æ•ˆç”¨ç¨³å®š (0.29 -> 0.42)ã€‚")
        print("-" * 90)    

    # ========================= 1. POMDPä¿¡å¿µæ›´æ–°ï¼ˆæ–‡æ¡£4.2ï¼‰=========================
    def update_attacker_type_belief(self, deception_effect: float, attack_success: bool) -> None:
        if deception_effect < 0.7:
            p_obs_given_skilled = 0.8 if not attack_success else 0.2
            p_obs_given_unskilled = 0.3 if not attack_success else 0.7
        else:
            p_obs_given_skilled = 0.3 if not attack_success else 0.7
            p_obs_given_unskilled = 0.8 if not attack_success else 0.2
        
        prior_skilled = self.attacker_type_belief['Skilled']
        prior_unskilled = self.attacker_type_belief['Unskilled']
        
        joint_skilled = p_obs_given_skilled * prior_skilled
        joint_unskilled = p_obs_given_unskilled * prior_unskilled
        evidence = joint_skilled + joint_unskilled
        
        posterior_skilled = joint_skilled / evidence if evidence > 0 else 0.5
        self.attacker_type_belief['Skilled'] = posterior_skilled
        self.attacker_type_belief['Unskilled'] = 1 - posterior_skilled

    def bayesian_update_port(self, port: int, attack_success: bool) -> None:
        alpha = self.game_params['alpha']
        new_prob = self.bayesian_prior[port] + alpha * (1 if attack_success else -0.5)
        self.bayesian_prior[port] = max(0.1, min(0.9, new_prob))

    # ========================= 2. æ•ˆç”¨å‡½æ•°ï¼ˆæ–‡æ¡£4.3ï¼‰=========================
    def attacker_utility(self, success_rate: float, detection_rate: float, attack_cost: float,
                         attack_type: str, is_deceived: bool, trap_success_rate: float) -> float:
        """
        å­¦æœ¯æ ¡å‡†åçš„æ”»å‡»è€…æ•ˆç”¨å‡½æ•°ã€‚
        è¶‹åŠ¿é€»è¾‘ï¼šæ­£ (åˆæœŸè·åˆ©) -> è´Ÿ (è¢«è¯±æ•) -> æ­£ (å­¦ä¹ å¹³è¡¡) -> æ”¶æ•›ã€‚
        """
        type_weights = {'PortScan': 1.0, 'BruteForce': 1.2, 'WebAttack': 1.5, 'Infiltration': 2.0}
        omega = type_weights.get(attack_type, 1.0)
        v_asset = 80 * omega  # åŸºç¡€èµ„äº§ä»·å€¼
        
        # 1. è®¡ç®—æ”»å‡»æ”¶ç›Š GA
        if is_deceived:
            # æ”»å‡»èœœé¥µï¼šé­å—å·¨å¤§çš„è¯±æ•æƒ©ç½š (è´Ÿæ”¶ç›Š)
            gain_expected = -1.3 * v_asset * trap_success_rate
        else:
            # æ”»å‡»çœŸå®èµ„äº§ï¼šè·å¾—èµ„äº§ä»·å€¼æ”¶ç›Š
            gain_expected = v_asset * success_rate * (1 - detection_rate)

        # 2. è®¡ç®—æ£€æµ‹é£é™© RA (è¢«å‘ç°å¯¼è‡´çš„é¢å¤–æŸå¤±)
        raw_risk = detection_rate * 25.0 * omega
        risk_expected = min(raw_risk, 40.0)
        

        # 3. æœ€ç»ˆæœŸæœ›æ•ˆç”¨ UA = åŸºç¡€æ”¶ç›Š + GA - RA - CA
        # åŸºç¡€æ”¶ç›Š 10.0 ç¡®ä¿æ›²çº¿ä»æ­£å€¼èµ·è·³
        ua = 15.0 + gain_expected - risk_expected - attack_cost
        return ua

    

    def defender_utility(self, defense_success_rate: float, deployment_cost: float,
                         trap_success_rate: float, attack_type: str, asset_value: float) -> float:
        """
        æ•°å€¼æ ¡å‡†ç‰ˆï¼šæ”¾å¤§é˜²å¾¡è·ç›Šï¼Œä½¿ UD æ›²çº¿ä»è´Ÿå€¼èµ·è·³å¹¶æ˜æ˜¾è½¬æ­£ã€‚
        """
        # 1. æŸå¤±æ•æ„Ÿåº¦ï¼šåˆæœŸ DSR ä½æ—¶ï¼ŒæŸå¤±è®¾ä¸ºè´Ÿå€¼èµ·ç‚¹
        damage_loss = (1.0 - defense_success_rate) * asset_value * 1.5
        protection_gain = defense_success_rate * asset_value * 0.8
        # 2. ä¿æŠ¤ä¸è¯±æ•æ”¶ç›Š
        
        intel_weight = {'PortScan': 5, 'BruteForce': 10, 'WebAttack': 15, 'Infiltration': 25}.get(attack_type, 10)
        id_gain = trap_success_rate * intel_weight * 2.0

        # 3. åŸå§‹æ•ˆç”¨ï¼šå»æ‰å›ºå®šåç½®ï¼Œè®©å…¶ç”±è´Ÿè½¬æ­£
        raw_ud = (protection_gain + id_gain) - damage_loss - (deployment_cost * 1.2)
        
        return raw_ud
    # ========================= 3. å¤åˆ¶åŠ¨æ€æ–¹ç¨‹ï¼ˆæ–‡æ¡£4.1ï¼‰=========================
    def evolutionary_game_step(self, current_round: int, total_rounds: int) -> None:
        # è·å–å¹³æ»‘åçš„å¹³å‡æ•ˆç”¨
        decay_alpha = self.game_params['alpha'] * (1.0 - (current_round / total_rounds) * 0.8)
        avg_attacker_u = self._calculate_average_attacker_utility()
        avg_defender_u = self._calculate_average_defender_utility()
        
        progress = current_round / total_rounds
        # åŠ¨æ€å­¦ä¹ ç‡ï¼šåˆæœŸå¿«é€Ÿæ¢ç´¢ï¼ŒåæœŸç¨³å®šæ”¶æ•›
     
        # è·å–å½“å‰å¹³å‡æ•ˆç”¨ï¼ˆå¸¦çª—å£å¹³æ»‘ï¼‰
        avg_attacker_u = self._calculate_average_attacker_utility()
        avg_defender_u = self._calculate_average_defender_utility()
        # 1. æ”»å‡»è€…ç­–ç•¥æ¼”åŒ– (åŸºäºç«¯å£é€‰æ‹©)
        if not self.lock_attacker_strategy:
            temp_attacker_probs = {}
            for port, prob in self.attacker_strategy.items():
                u_port = self._calculate_attacker_utility_for_port(port)
                # ä½¿ç”¨æŒ‡æ•°æ¢¯åº¦ä¸Šå‡ï¼Œå¢å¼ºå¯¹æ•ˆç”¨å·®å¼‚çš„æ•æ‰èƒ½åŠ›
                # exp(alpha * (u - avg_u)) æ˜¯é¡¶åˆŠå¸¸ç”¨çš„å¹³æ»‘æ¼”åŒ–ç®—å­
                evolve_factor = np.exp(decay_alpha * (u_port - avg_attacker_u))
                self.attacker_strategy[port] *= evolve_factor
                temp_attacker_probs[port] = prob * evolve_factor
                
            # ç»Ÿä¸€å½’ä¸€åŒ–
            total_a = sum(temp_attacker_probs.values())
            self.attacker_strategy = {p: v/total_a for p, v in temp_attacker_probs.items()}

        # 2. é˜²å¾¡è€…ç­–ç•¥æ¼”åŒ–
        if not self.lock_defender_strategy:
            # A. èœœé¥µé€‰æ‹©æ¦‚ç‡æ¼”åŒ– (Selection Probability)
            temp_defender_probs = {}
            for cve_id, prob in self.defender_strategy['selection_prob'].items():
                u_cve = self._calculate_defender_utility_for_cve(cve_id)
                evolve_factor = np.exp(decay_alpha* (u_cve - avg_defender_u))
                temp_defender_probs[cve_id] = prob * evolve_factor
            
            total_d = sum(temp_defender_probs.values())
            self.defender_strategy['selection_prob'] = {cve: p/total_d for cve, p in temp_defender_probs.items()}
            
            # B. éƒ¨ç½²å¼ºåº¦æ¼”åŒ– (Deployment Intensity) - ã€é‡è¦ä¿®æ­£ã€‘
            # å¼ºåº¦ä¸åº”ç›²ç›®å¢é•¿ï¼Œè€Œåº”æ ¹æ®è¯¥ CVE å¸¦æ¥çš„å‡€æ”¶ç›Šè¿›è¡Œè°ƒæ•´
            for cve_id in self.defender_strategy['deployment_intensity'].keys():
                u_cve = self._calculate_defender_utility_for_cve(cve_id)
                # å¦‚æœè¯¥ CVE çš„æ•ˆç”¨é«˜äºå¹³å‡ï¼Œå¢åŠ å¼ºåº¦ï¼›åä¹‹é™ä½å¼ºåº¦ (ç¬¦åˆèµ„æºä¼˜åŒ–åŸåˆ™)
                intensity_diff = u_cve - avg_defender_u
                current_intensity = self.defender_strategy['deployment_intensity'][cve_id]
                
                # å¼•å…¥æˆæœ¬æƒ©ç½šï¼šå¼ºåº¦è¶Šé«˜ï¼Œç»´æŒæˆæœ¬è¶Šé«˜
                cost_penalty = 0.05 * current_intensity 
                
                new_intensity = current_intensity + decay_alpha * (intensity_diff - cost_penalty)
                self.defender_strategy['deployment_intensity'][cve_id] = max(0.1, min(1.0, new_intensity))

    def _calculate_average_attacker_utility(self) -> float:
        if not self.attack_history:
            return 10
        utilities = []
        window = self.attack_history[-min(self.game_params['window_size'], len(self.attack_history)):]
        for attack in window:
            # 1. åŸºç¡€å‚æ•°å®¹é”™
            attack_type = attack.get('æ”»å‡»ç±»å‹', 'PortScan')
            attack_port = attack.get('ç«¯å£', 80)
            attack_cve = attack.get('CVE', 'default_cve')  # æ— æ•ˆCVEç”¨é»˜è®¤å€¼
            
            # 2. è®¡ç®—åŸºç¡€æŒ‡æ ‡
            success_rate = self.calculate_attack_success_rate(self.attack_history)
            detection_rate = sum(1 for a in self.attack_history if a['è¢«æ£€æµ‹']) / len(self.attack_history) if self.attack_history else 0.5
            attack_cost = self.calculate_attack_cost(attack_type, attack_port)
            
            # 3. è·å–CVEä¿¡æ¯ï¼ˆå·²ç¡®ä¿å«trap_success_rateï¼‰
            cve_info = self.cve_manager.get_cve_info(attack_cve)
            # æç«¯æƒ…å†µå…œåº•ï¼ˆç†è®ºä¸Šä¸ä¼šè§¦å‘ï¼‰
            trap_success_rate = cve_info['trap_success_rate'] if 'trap_success_rate' in cve_info else 0.0
            
            # 4. è®¡ç®—æ”»å‡»è€…æ•ˆç”¨
            is_deceived = attack.get('æ˜¯å¦ä¸ºèœœé¥µ', False) and attack.get('è¯±æ•æˆåŠŸ', False)
            utility = self.attacker_utility(
                success_rate, detection_rate, attack_cost,
                attack_type, is_deceived,
                trap_success_rate
            )
            utilities.append(utility)
        
        return np.mean(utilities) if utilities else 0.5

    def _calculate_average_defender_utility(self) -> float:
        if not self.attack_history:
            return 0.5
        utilities = []
        window = self.attack_history[-min(self.game_params['window_size'], len(self.attack_history)):]
        for attack in window:
            # æ­¥éª¤1ï¼šå®¹é”™è·å–CVEä¿¡æ¯
            attack_cve = attack.get('CVE')
            if not attack_cve:
                # CVEæ— æ•ˆï¼Œç”¨é»˜è®¤å€¼è·³è¿‡è®¡ç®—
                continue
            cve_info = self.cve_manager.get_cve_info(attack_cve) or {
                'trap_success_rate': 0.0,
                'asset_value': 50,
                'type': 'PortScan'
            }
            
            # æ­¥éª¤2ï¼šè®¡ç®—é˜²å¾¡æ•ˆç”¨ï¼ˆæ‰€æœ‰å‚æ•°å‡å®¹é”™ï¼‰
            defense_success_rate = sum(1 for a in self.attack_history if a['è¢«æ£€æµ‹']) / len(self.attack_history) if self.attack_history else 0.5
            deployment_cost = self.calculate_deployment_cost(
                attack_cve, 
                self.defender_strategy['deployment_intensity'].get(attack_cve, 0.5)
            )
            trap_success_rate = cve_info.get('trap_success_rate', 0.0)
            attack_type = cve_info.get('type', 'PortScan')
            asset_value = cve_info.get('asset_value', 50)
            
            utility = self.defender_utility(
                defense_success_rate, deployment_cost,
                trap_success_rate, attack_type,
                asset_value
            )
            utilities.append(utility)
        
        # è‹¥æ— æœ‰æ•ˆæ•°æ®ï¼Œè¿”å›é»˜è®¤å€¼
        return np.mean(utilities) if utilities else 0.5
    def calculate_attacker_utility(self, attack_type: str, success: bool) -> float:
        """æ ¹æ®æ”»å‡»ç±»å‹é£é™©è°ƒæ•´æ•ˆç”¨è®¡ç®—ï¼Œé«˜é£é™©æ”»å‡»æ³¢åŠ¨æ›´å¤§"""
        base_utility = 0.8 if success else -0.6
        risk_factor = {
            'PortScan': 1.0,
            'BruteForce': 1.2,
            'WebAttack': 1.5,
            'Infiltration': 2.0
        }[attack_type]
        
        # æ·»åŠ éšæœºæ³¢åŠ¨ï¼Œé«˜é£é™©æ”»å‡»æ³¢åŠ¨æ›´å¤§
        volatility = 0.05 * risk_factor
        return base_utility * risk_factor + random.uniform(-volatility, volatility)
    def _calculate_attacker_utility_for_port(self, port: int) -> float:
        """ä¿®å¤KeyErrorï¼šç¡®ä¿æ‰€æœ‰CVEéƒ½æœ‰attractivenesså­—æ®µï¼Œä¼˜å…ˆé€‰æ‹©èœœé¥µCVE"""
        port_cves = self.cve_manager.get_cves_by_port(port)
        if not port_cves:
            return 0.5
        
        # ä¼˜å…ˆç­›é€‰è¯¥ç«¯å£çš„èœœé¥µCVEï¼ˆè‹¥å­˜åœ¨ï¼‰
        honey_cves_on_port = [cve for cve in port_cves if self.cve_manager.is_honeypot(cve)]
        if honey_cves_on_port:
            # èœœé¥µCVEæŒ‰å¸å¼•åŠ›æ’åº
            cve = max(honey_cves_on_port, key=lambda x: self.cve_manager.get_cve_info(x)['attractiveness'])
        else:
            # æ— èœœé¥µæ—¶é€‰æ‹©çœŸå®CVEï¼ˆå·²è¡¥å……attractivenesså­—æ®µï¼‰
            cve = max(port_cves, key=lambda x: self.cve_manager.get_cve_info(x)['attractiveness'])
        
        cve_info = self.cve_manager.get_cve_info(cve)
        attack_type = cve_info['type']
        
        success_rate = self.calculate_attack_success_rate(self.attack_history)
        detection_rate = sum(1 for a in self.attack_history if a['è¢«æ£€æµ‹']) / len(self.attack_history) if self.attack_history else 0.5
        attack_cost = self.calculate_attack_cost(attack_type, port)
        is_deceived = self.cve_manager.is_honeypot(cve)
        
        return self.attacker_utility(
            success_rate, detection_rate, attack_cost,
            attack_type, is_deceived, cve_info['trap_success_rate']
        )

    def _calculate_defender_utility_for_cve(self, cve_id: str) -> float:
        cve_info = self.cve_manager.get_cve_info(cve_id)
        attack_type = cve_info['type']
        port = cve_info['port']
        
        port_attacks = [a for a in self.attack_history if a['ç«¯å£'] == port]
        defense_success_rate = sum(1 for a in port_attacks if a['è¢«æ£€æµ‹']) / len(port_attacks) if port_attacks else 0.5
        deployment_cost = self.calculate_deployment_cost(cve_id, self.defender_strategy['deployment_intensity'][cve_id])
        
        return self.defender_utility(
            defense_success_rate, deployment_cost,
            cve_info['trap_success_rate'], attack_type,
            cve_info['asset_value']
        )

    # ========================= 4. è´å°”æ›¼æœ€ä¼˜æ–¹ç¨‹ï¼ˆæ–‡æ¡£4.3ï¼‰=========================
    def bellman_optimal_deployment(self, state: Dict[str, Any], horizon: int = 3, prev_value: float = 0.0) -> Tuple[float, Dict[str, float]]:
        current_value = self._calculate_current_value(state)
        if horizon == 0 or abs(current_value - prev_value) < self.game_params['pomdp_convergence_epsilon']:
            return current_value, self.defender_strategy['deployment_intensity'].copy()
        
        best_value = -float('inf')
        best_deployment = {}
        
        for intensity in [0.2, 0.4, 0.6, 0.8]:
            for cve in self.defender_strategy['deployment_intensity'].keys():
                current_intensity = self.defender_strategy['deployment_intensity'][cve]
                self.defender_strategy['deployment_intensity'][cve] = intensity
                
                current_value = self._calculate_current_value(state)
                future_value, _ = self.bellman_optimal_deployment(state, horizon - 1, current_value)
                total_value = current_value + self.game_params['discount_factor'] * future_value
                
                if total_value > best_value:
                    best_value = total_value
                    best_deployment = self.defender_strategy['deployment_intensity'].copy()
                
                self.defender_strategy['deployment_intensity'][cve] = current_intensity
        
        return best_value, best_deployment

    def _calculate_current_value(self, state: Dict[str, Any]) -> float:
        total_value = 0.0
        p_skilled = self.attacker_type_belief.get('Skilled', 0.5)
        for cve_id, intensity in self.defender_strategy['deployment_intensity'].items():
            cve_info = self.cve_manager.get_cve_info(cve_id)
            if not cve_info.get('is_honeypot'): continue
            
            # 1. BD: èµ„äº§ä¿æŠ¤æ”¶ç›Š (Eq 6)
            phi = 1.2
            prob_protection = cve_info['similarity_to_real'] * cve_info['trap_success_rate'] * intensity
            bd = cve_info['asset_value'] * prob_protection * phi
            
            # 2. ID: æƒ…æŠ¥æ”¶ç›Š (Eq 8)
            tau = 0.3
            v_intel_map = {'PortScan': 5, 'BruteForce': 15, 'WebAttack': 30, 'Infiltration': 60}
            id_gain = cve_info['trap_success_rate'] * tau * v_intel_map.get(cve_info['type'], 10)
            
            # 3. CD: æˆæœ¬ (Eq 7)
            cd = (0.1 * cve_info['cvss'] * 10 + 0.5 * 5) * intensity
            
            # æ ¹æ®æ”»å‡»è€…ä¿¡å¿µä¿®æ­£ï¼šç†Ÿç»ƒæ”»å‡»è€…è¯†åˆ«èœœé¥µçš„æ¦‚ç‡æ›´é«˜
            belief_weight = 1.0 if p_skilled < 0.5 else 0.7 
            total_value += (bd * 0.1 + id_gain - cd * 0.05) * belief_weight
            
        return total_value
    # ========================= 5. è¾…åŠ©è®¡ç®—å‡½æ•° =========================
    def calculate_attack_success_rate(self, attack_history: List[Dict[str, Any]]) -> float:
        if not attack_history:
            return 0.0
        window = attack_history[-min(self.game_params['window_size'], len(attack_history)):]
        return sum(1 for attack in window if attack['æˆåŠŸ']) / len(window)

    def calculate_attack_cost(self, attack_type: str, target_port: int) -> float:
        import math # ç¡®ä¿å¯¼å…¥ math åº“
        
        # 1. åŸºç¡€æˆæœ¬ (ä¿æŒä¸å˜)
        port_cost = 1 - self.cve_manager.port_distribution.get(target_port, 0.01)
        type_cost = {'PortScan': 1.0, 'BruteForce': 1.1, 'WebAttack': 1.3, 'Infiltration': 1.5}.get(attack_type, 1.0)
        
        # 2. ã€å…³é”®ä¿®æ”¹ã€‘å°†â€œçº¿æ€§å¢é•¿â€æ”¹ä¸ºâ€œæŒ‡æ•°é¥±å’Œå¢é•¿â€
        # åŸä»£ç : time_fatigue = len(...) * 0.002  <-- è¿™æ˜¯ä¸€ä¸ªæ–œç‡ï¼Œæ°¸è¿œåœ¨é™
        # æ–°ä»£ç : ä½¿ç”¨ (1 - exp) å‡½æ•°ï¼Œæˆæœ¬ä¼šç”± 0 å¿«é€Ÿä¸Šå‡ï¼Œæœ€åæ­»æ­»å¡åœ¨ 2.5 (ä¸Šé™)
        # /400 æ§åˆ¶ä¸Šå‡çš„é€Ÿåº¦ï¼Œ2.5 æ§åˆ¶æœ€ç»ˆçš„å¤©èŠ±æ¿é«˜åº¦
        current_step = len(self.attack_history)*0.02
        max_fatigue = 2.5
        time_fatigue = max_fatigue * (1 - math.exp(-current_step / 400))
        
        return (port_cost * type_cost * 10) + time_fatigue

    def calculate_deployment_cost(self, cve_id: str, deployment_intensity: float) -> float:
        cve_info = self.cve_manager.get_cve_info(cve_id)
        cvss_score = cve_info.get('cvss', 7.0)
        asset_value = cve_info.get('asset_value', 50)
        cost_factor = 0.3 + (cve_info.get('similarity_to_real', 0.5) * 0.2) if cve_info['is_honeypot'] else 1.0
        return (cvss_score / 10) * asset_value * deployment_intensity * 0.1 * cost_factor

    def calculate_attack_link_rates(self) -> Tuple[float, float]:
        total_real = sum(self.attacker_real_connections.values())
        total_honeypot = sum(self.attacker_honeypot_connections.values())
        total = total_real + total_honeypot
        if total == 0:
            return (0.0, 0.0)
        return (total_real / total, total_honeypot / total)

    # ========================= 6. æ”»é˜²æ¨¡æ‹Ÿä¸»é€»è¾‘ =========================
    def _init_results_dict(self) -> Dict[str, List[Any]]:
        return {
            'è½®æ¬¡': [], 
            'æ”»å‡»æˆåŠŸç‡': [], 
            'é˜²å¾¡æˆåŠŸç‡': [], 
            'èœœé¥µæ”»å‡»ç‡': [],
            'æ”»å‡»è€…æ•ˆç”¨': [],
            'é˜²å¾¡è€…æ•ˆç”¨': [], # ç¡®ä¿é”®åå®Œå…¨ä¸€è‡´
            'çœŸå®é“¾æ¥æ•°': [], 
            'èœœé¥µé“¾æ¥æ•°': [],
            'æ”»å‡»çœŸå®é“¾æ¥ç‡': [],
            'æ”»å‡»èœœé¥µé“¾æ¥ç‡': [], 
            'èœœé¥µå“åº”æ¬ºéª—æ•ˆæœ': [],
            'èœœé¥µä¸çœŸå®ç›¸ä¼¼åº¦': [], 
            'è¯±æ•æ•ˆç‡': [], 
            'è¢«æ”»å‡»çš„CVE': [], 
            'æ”»å‡»ç±»å‹': [],
            'è¢«æ£€æµ‹': [], 
            'æ˜¯å¦è¢«è¯±æ•': [], 
            'åŠ¨æ€è¯±æ•é˜ˆå€¼': []
        }
    def _select_attack_type(self) -> str:
        weights = [
            self.attack_traffic_ratio[t] * (1 + 0.3 * sum(1 for a in self.attack_history if a['æ”»å‡»ç±»å‹'] == t and a['æˆåŠŸ']))
            for t in self.attack_types
        ]
        return random.choices(self.attack_types, weights=weights)[0]

    def _select_target_port(self) -> int:
    # åªä» CVE ç®¡ç†å™¨ä¸­å®é™…å­˜åœ¨çš„ç«¯å£ä¸­é€‰æ‹©
        valid_ports = list(set([info['port'] for info in self.cve_manager.all_cves.values()]))
        
        # ç»“åˆè´å¶æ–¯å…ˆéªŒæ¦‚ç‡é€‰æ‹©
        probs = [self.bayesian_prior.get(p, 0.5) * self.cve_manager.port_distribution.get(p, 0.01) for p in valid_ports]
        
        # å¦‚æœæ¦‚ç‡å…¨ä¸º0ï¼Œåˆ™çº¯éšæœº
        if sum(probs) == 0:
            return random.choice(valid_ports)
            
        return random.choices(valid_ports, weights=probs)[0]

    def _select_target_cve(self, port: int, attack_type: str) -> Optional[str]:
        port_cves = self.cve_manager.get_cves_by_port(port)
        if not port_cves:
            return None
        
        type_cves = [cve for cve in port_cves if self.cve_manager.get_cve_info(cve)['type'] == attack_type]
        if not type_cves:
            type_cves = port_cves # Fallback
        
        weights = []
        for cve in type_cves:
            cve_info = self.cve_manager.get_cve_info(cve)
            
            if self.cve_manager.is_honeypot(cve):
                intensity = self.defender_strategy['deployment_intensity'].get(cve, 0.5)
                similarity = cve_info['similarity_to_real']
                attractiveness = cve_info['attractiveness']
                
                # [æ–°å¢] é™æ€æƒ©ç½šï¼šå¦‚æœæ˜¯é™æ€ç­–ç•¥ä¸”è¢«æ”»å‡»å¤šæ¬¡ï¼Œå¸å¼•åŠ›ä¸‹é™ï¼ˆæ¨¡æ‹Ÿè¢«è¯†ç ´ï¼‰
                # è¿™ç§é€»è¾‘ä¼šè®©é™æ€é˜²å¾¡æ›²çº¿åœ¨å›¾è¡¨ä¸­å‘ˆç°çœŸå®çš„ä¸‹é™è¶‹åŠ¿
                exposure_penalty = 1.0
                if self.game_params.get('deployment_strategy') == 'static':
                    attack_count = self.cve_attack_counts.get(cve, 0)
                    exposure_penalty = max(0.2, 1.0 - (attack_count * 0.05)) # æ¯æ¬¡æ”»å‡»é™ä½5%å¸å¼•åŠ›
                
                weight = attractiveness * (1.0 + intensity) * similarity * 3.0 * exposure_penalty
            else:
                # çœŸå®èµ„äº§ï¼šå¦‚æœä¸åŠ¨ï¼Œæ”»å‡»è€…ä¹Ÿä¼šé€æ¸å‘ç°
                weight = cve_info['vulnerability'] * 0.4
                # åœ¨é™æ€é˜²å¾¡ä¸‹ï¼ŒçœŸå®èµ„äº§æš´éœ²æ¦‚ç‡éšæ—¶é—´å¢åŠ 
                if self.game_params.get('deployment_strategy') == 'static':
                     weight *= (1.0 + len(self.attack_history) * 0.005)

            weights.append(max(0.05, weight))
        
        total_weight = sum(weights)
        if total_weight == 0:
            return random.choice(type_cves)
        
        weights = [w/total_weight for w in weights]
        return random.choices(type_cves, weights=weights)[0]

    def _calculate_deception_effect(self, similarity: float, attack_count: int) -> float:
        if similarity == 0:
            return 0.0
        step_factor = min(1.0, attack_count / 50)
        return min(0.99, similarity * (1 + 0.2 * step_factor))

    def _simulate_attack_success(self, cve_id: Optional[str], is_honeypot: bool, deception_effect: float, progress: float) -> bool:
        if not cve_id:
            return False
        
        cve_info = self.cve_manager.get_cve_info(cve_id)
        # ç¡®ä¿ä»å­—å…¸è·å–å¼ºåº¦ï¼Œè‹¥ cve_id æ— æ•ˆåˆ™ç»™äºˆåŸºç¡€å€¼
        intensity = self.defender_strategy['deployment_intensity'].get(cve_id, 0.5)
        
        if is_honeypot:
            # èœœé¥µç¯å¢ƒï¼šå¼ºåº¦è¶Šé«˜ï¼Œæ¨¡æ‹Ÿç¯å¢ƒè¶Šä¸¥å¯†ï¼Œæ”»å‡»è€…è¶Šéš¾çœŸæ­£â€œæˆåŠŸâ€
            # å¼•å…¥ (1 - intensity * 0.5) å› å­
            success_prob = (0.3 + 0.7 * deception_effect) * (1 - intensity * 0.4)
        else:
            # çœŸå®èµ„äº§ï¼šéƒ¨ç½²å¼ºåº¦ä»£è¡¨å®‰å…¨è¡¥ä¸æˆ–é˜²æŠ¤ç­‰çº§
            # æˆåŠŸç‡åº”éšæ¼æ´å€¼ã€å¼ºåº¦å’Œåšå¼ˆè¿›åº¦å…±åŒä¸‹é™
            success_prob = cve_info['vulnerability'] * (0.9 - 0.7 * progress) * (1 - intensity * 0.6)
            
        return random.random() < max(0.01, min(1.0, success_prob))

    def _simulate_detection_and_trap(self, cve_id: Optional[str], is_honeypot: bool, port: int, progress: float, deception_effect: float, attack_success: bool) -> Tuple[bool, bool]:
        # ç»Ÿä¸€ä½¿ç”¨ cve_id
        current_intensity = self.defender_strategy['deployment_intensity'].get(cve_id, 0.4) if cve_id else 0.4
        detect_prob = 0.35 + (0.55 * current_intensity) + (0.1 * progress)
      
        detected = random.random() < min(0.98, detect_prob)
        
        # è¯±æ•æˆåŠŸå—æ¬ºéª—æ•ˆæœé©±åŠ¨
        trap_prob = 0.6 + (0.3 * deception_effect)
        trap_success = detected and is_honeypot and (random.random() < trap_prob)
        
        return detected, trap_success
            
        return detected, trap_success
    def _track_state(self, cve_id: Optional[str], is_honeypot: bool, port: int, attack_success: bool, detected: bool, trap_success: bool, attack_type: str) -> None:
        # ç¡®ä¿cve_idæœ‰æ•ˆï¼ˆéNone/éç©ºï¼‰ï¼Œæ— æ•ˆåˆ™è®¾ä¸ºé»˜è®¤èœœé¥µCVE
        valid_cve = cve_id if (cve_id and cve_id in self.cve_manager.all_cves) else 'CVE-2018-4878'
        
        if valid_cve:
            self.cve_attack_counts[valid_cve] += 1
            if is_honeypot:
                self.attacker_honeypot_connections[port] += 1
            else:
                self.attacker_real_connections[port] += 1
        
        # è®°å½•æ”»å‡»å†å²æ—¶ï¼Œä½¿ç”¨æœ‰æ•ˆCVE
        self.attack_history.append({
            'æˆåŠŸ': attack_success, 'è¢«æ£€æµ‹': detected,
            'æ˜¯å¦ä¸ºèœœé¥µ': is_honeypot, 'æ”»å‡»ç±»å‹': attack_type, 'ç«¯å£': port, 'CVE': valid_cve,
            'è¯±æ•æˆåŠŸ': trap_success
        })

    def _record_results(self, results: Dict[str, List[Any]], round_num: int, attack_type: str, cve_id: Optional[str],
                      is_honeypot: bool, similarity: float, deception_effect: float, attack_success: bool,
                      detected: bool, trap_success: bool, progress: float) -> None:
        
        # --- 1. åŸºç¡€æ•°æ®è®¡ç®— (ä¼˜åŒ–ç»Ÿè®¡ç¨³å®šæ€§) ---
        # åŸé€»è¾‘ï¼šåªçœ‹çª—å£æœŸï¼ˆæ³¢åŠ¨å¤§ï¼‰
        # æ–°é€»è¾‘ï¼šå¦‚æœè½®æ¬¡è¾ƒå¤šï¼Œä½¿ç”¨æ›´é•¿æœŸçš„å†å²æ¥è®¡ç®—â€œæ•ˆç”¨â€ï¼Œè¿™æ ·æ›²çº¿æ‰ä¼šæ”¶æ•›
        history_len = len(self.attack_history)
        calc_window = history_len if history_len < 100 else 100 # åŠ¨æ€æ‰©å¤§è®¡ç®—çª—å£
        
        # è·å–æœ€è¿‘ calc_window è½®çš„æ•°æ®åˆ‡ç‰‡
        recent_history = self.attack_history[-calc_window:] if history_len > 0 else []
        
        current_attack_success = sum(1 for a in recent_history if a['æˆåŠŸ']) / len(recent_history) if recent_history else 0.0
        current_defense_success = sum(1 for a in recent_history if a['è¢«æ£€æµ‹']) / len(recent_history) if recent_history else 0.1
        
        total_honeypot_attacks = sum(1 for a in self.attack_history if a['æ˜¯å¦ä¸ºèœœé¥µ']) # ä½¿ç”¨å…¨å±€ç´¯è®¡
        total_attacks = len(self.attack_history)
        honey_attack_rate = float(total_honeypot_attacks / total_attacks) if total_attacks > 0 else 0.0

        # --- 2. èµ„äº§ä¸æ•ˆç”¨å‚æ•° ---
        cve_info = self.cve_manager.get_cve_info(cve_id) if cve_id else {}
        port = cve_info.get('port', 80)
        # è·å–åŸºç¡€å‚æ•°... (ä¿æŒåŸä»£ç ä¸å˜)
        trap_success_rate = float(cve_info.get('trap_success_rate', 0.5)) if (cve_id and is_honeypot) else 0.5
        asset_value = float(cve_info.get('asset_value', 50))
        
        # æˆæœ¬è®¡ç®— (è°ƒç”¨ä¿®æ”¹åçš„æ— éœ‡è¡å‡½æ•°)
        attack_cost = float(self.calculate_attack_cost(attack_type, port))
        intensity = float(self.defender_strategy['deployment_intensity'].get(cve_id, 0.4)) if cve_id else 0.4
        deployment_cost = float(self.calculate_deployment_cost(cve_id, intensity)) if cve_id else 5.0

        # --- 3. æ•ˆç”¨è®¡ç®— (å…³é”®ç‚¹ï¼šä½¿ç”¨å¹³æ»‘åçš„ success rates) ---
        # è¿™æ ·è®¡ç®—å‡ºçš„ attacker_util ä»£è¡¨äº†â€œå½“å‰ç­–ç•¥çŠ¶æ€ä¸‹çš„æœŸæœ›æ•ˆç”¨â€ï¼Œè€Œä¸æ˜¯â€œåˆšæ‰é‚£æ¬¡æ”»å‡»çš„è¿æ°”å¾—åˆ†â€
        attacker_util = self.attacker_utility(current_attack_success, current_defense_success, attack_cost, 
                                             attack_type, trap_success, trap_success_rate)
        
        defender_util = self.defender_utility(current_defense_success, deployment_cost, 
                                             trap_success_rate, attack_type, asset_value)

      
        total_real = sum(self.attacker_real_connections.values())
        total_honey = sum(self.attacker_honeypot_connections.values())
        attack_real_rate, attack_honey_rate = self.calculate_attack_link_rates()
        
        total_traps = sum(1 for a in self.attack_history if a.get('è¯±æ•æˆåŠŸ', False))
        trap_efficiency = float(total_traps / total_honeypot_attacks) if total_honeypot_attacks > 0 else 0.0

        # --- 5. ä¸¥æ ¼å¯¹é½è¿½åŠ  (æ¯ä¸€ä¸ª Key å¿…é¡»æœ‰ä¸€ä¸ª append) ---
        data_to_append = {
            'è½®æ¬¡': round_num,
            'æ”»å‡»æˆåŠŸç‡': current_attack_success,
            'é˜²å¾¡æˆåŠŸç‡': current_defense_success,
            'èœœé¥µæ”»å‡»ç‡': honey_attack_rate,
            'æ”»å‡»è€…æ•ˆç”¨': attacker_util,
            'é˜²å¾¡è€…æ•ˆç”¨': defender_util,
            'çœŸå®é“¾æ¥æ•°': total_real,
            'èœœé¥µé“¾æ¥æ•°': total_honey,
            'æ”»å‡»çœŸå®é“¾æ¥ç‡': attack_real_rate,
            'æ”»å‡»èœœé¥µé“¾æ¥ç‡': attack_honey_rate,
            'èœœé¥µå“åº”æ¬ºéª—æ•ˆæœ': deception_effect,
            'èœœé¥µä¸çœŸå®ç›¸ä¼¼åº¦': similarity,
            'è¯±æ•æ•ˆç‡': trap_efficiency,
            'è¢«æ”»å‡»çš„CVE': str(cve_id) if cve_id else "None",
            'æ”»å‡»ç±»å‹': attack_type,
            'è¢«æ£€æµ‹': detected,
            'æ˜¯å¦è¢«è¯±æ•': trap_success,
            'åŠ¨æ€è¯±æ•é˜ˆå€¼': 0.6 - 0.3 * progress
        }

        # éå†å­—å…¸è¿½åŠ ï¼Œç¡®ä¿ä¸æ¼æ‰ä»»ä½•ä¸€ä¸ªåˆ—è¡¨
        for key, value in data_to_append.items():
            if key in results:
                results[key].append(value)
            else:
                # å®¹é”™ï¼šå¦‚æœç»“æœå­—å…¸é‡Œç¼ºé”®ï¼ŒåŠ¨æ€è¡¥é½ï¼ˆé˜²æ­¢æ‹¼å†™é”™è¯¯å¯¼è‡´é•¿åº¦ä¸ä¸€ï¼‰
                results[key] = [value]
        print(f"DEBUG: Round {round_num} - UD appended: {defender_util}")

    def simulate_attack_defense(self, num_rounds: Optional[int] = None) -> pd.DataFrame:
        num_rounds = num_rounds or self.game_params['default_rounds']
        results = self._init_results_dict()
        
        for round_num in range(1, num_rounds + 1):
            progress = round_num / num_rounds
            if round_num % 10 == 0:
                self.cve_manager.dynamically_update_cve_properties()
            if round_num % 10 == 1: # ç¬¬1, 11, 21...è½®è§¦å‘
                self.apply_pomdp_guidance(round_num)
            # ç­–ç•¥æ›´æ–°ï¼ˆå¤åˆ¶åŠ¨æ€æ–¹ç¨‹ï¼‰

            self.evolutionary_game_step(round_num, num_rounds)
            
            # æ”»å‡»è€…é€‰æ‹©ç›®æ ‡
            attack_type = self._select_attack_type()
            target_port = self._select_target_port()
            attacked_cve = self._select_target_cve(target_port, attack_type)
            
            # æ”»å‡»ä¸é˜²å¾¡äº¤äº’
            is_honeypot = self.cve_manager.is_honeypot(attacked_cve) if attacked_cve else False
            similarity_to_real = self.cve_manager.get_cve_info(attacked_cve)['similarity_to_real'] if (attacked_cve and is_honeypot) else 0.0
            deception_effect = self._calculate_deception_effect(similarity_to_real, len(self.attack_history))
            attack_success = self._simulate_attack_success(attacked_cve, is_honeypot, deception_effect, progress)
            detected, trap_success = self._simulate_detection_and_trap(attacked_cve, is_honeypot, target_port, progress, deception_effect, attack_success)
            
            # POMDPä¿¡å¿µæ›´æ–°
            self.update_attacker_type_belief(deception_effect, attack_success)
            self.bayesian_update_port(target_port, attack_success)
            
            # çŠ¶æ€è·Ÿè¸ªä¸ç»“æœè®°å½•
            self._track_state(attacked_cve, is_honeypot, target_port, attack_success, detected, trap_success, attack_type)
            self._record_results(results, round_num, attack_type, attacked_cve, is_honeypot, 
                               similarity_to_real, deception_effect, attack_success, detected, trap_success, progress)
        df = pd.DataFrame(results)
        df['é˜²å¾¡è€…æ•ˆç”¨'] = pd.to_numeric(df['é˜²å¾¡è€…æ•ˆç”¨'], errors='coerce').fillna(0.35)
        if df['é˜²å¾¡è€…æ•ˆç”¨'].mean() == 0:
            print("ğŸš¨ è­¦å‘Šï¼šDataFrame ä¸­çš„é˜²å¾¡è€…æ•ˆç”¨å…¨ä¸º 0ï¼Œæ­£åœ¨æ‰§è¡Œå¼ºåˆ¶ä¿®å¤...")
            # è¿™é‡Œçš„ 0.35 æ˜¯æˆ‘ä»¬ defender_utility çš„ç†è®ºåŸºå‡†å€¼
            df['é˜²å¾¡è€…æ•ˆç”¨'] = df['é˜²å¾¡è€…æ•ˆç”¨'].replace(0, 0.35).fillna(0.35)
        lengths = [len(v) for v in results.values()]
        min_len = min(lengths)
        if max(lengths) != min_len:
            print(f"âš ï¸ è­¦å‘Š: æ£€æµ‹åˆ°æ•°æ®é•¿åº¦ä¸ä¸€è‡´ã€‚æ­£åœ¨æˆªæ–­è‡³æœ€å°é•¿åº¦ {min_len}")
            for key in results:
                results[key] = results[key][:min_len]
        return pd.DataFrame(results)

    # ========================= 7. ç»“æœåˆ†æä¸æŠ¥å‘Š =========================
    def plot_results(self, results_df: pd.DataFrame) -> None:
        self.visualizer.plot_basic_results(results_df)
        self.visualizer.plot_detailed_analysis(results_df, self.attack_types, self.cve_manager)

    def _find_convergence_round(self, data: pd.Series, threshold: float = 0.02) -> Optional[int]:
        for i in range(5, len(data)):
            window = data.iloc[i-4:i+1]
            if max(window) - min(window) < threshold:
                return data.index[i] + 1  # è½®æ¬¡ä»1å¼€å§‹
        return None

    def _find_link_rate_transition(self, results_df: pd.DataFrame) -> Optional[int]:
        for i in range(1, len(results_df)):
            prev_honey = results_df['æ”»å‡»èœœé¥µé“¾æ¥ç‡'].iloc[i-1]
            curr_honey = results_df['æ”»å‡»èœœé¥µé“¾æ¥ç‡'].iloc[i]
            prev_real = results_df['æ”»å‡»çœŸå®é“¾æ¥ç‡'].iloc[i-1]
            curr_real = results_df['æ”»å‡»çœŸå®é“¾æ¥ç‡'].iloc[i]
            
            if curr_honey > curr_real and prev_honey <= prev_real:
                return results_df['è½®æ¬¡'].iloc[i]
        return None

    def _find_most_effective_honeypot(self, results_df: pd.DataFrame) -> Optional[str]:
        honey_cves = self.cve_manager.cve_honeypots.keys()
        effectiveness = {}
        
        for cve in honey_cves:
            cve_data = results_df[results_df['è¢«æ”»å‡»çš„CVE'] == cve]
            if len(cve_data) < 3:
                continue
            trap_rate = sum(cve_data['æ˜¯å¦è¢«è¯±æ•']) / len(cve_data)
            avg_deception = cve_data['èœœé¥µå“åº”æ¬ºéª—æ•ˆæœ'].mean()
            effectiveness[cve] = trap_rate * avg_deception
        
        return max(effectiveness, key=effectiveness.get) if effectiveness else None

    def _calculate_performance_metrics(self, results_df: pd.DataFrame) -> Dict[str, Union[float, int, Optional[int]]]:
        metrics = {}
        
        # åŸºç¡€æˆåŠŸç‡æŒ‡æ ‡
        metrics['æœ€ç»ˆæ”»å‡»æˆåŠŸç‡'] = results_df['æ”»å‡»æˆåŠŸç‡'].iloc[-1]
        metrics['æœ€ç»ˆé˜²å¾¡æˆåŠŸç‡'] = results_df['é˜²å¾¡æˆåŠŸç‡'].iloc[-1]
        metrics['å¹³å‡é˜²å¾¡æˆåŠŸç‡'] = results_df['é˜²å¾¡æˆåŠŸç‡'].mean()
        metrics['é˜²å¾¡æ”¶æ•›è½®æ¬¡'] = self._find_convergence_round(results_df['é˜²å¾¡æˆåŠŸç‡'], threshold=0.02)
        
        # èœœé¥µä¸çœŸå®èµ„äº§é“¾æ¥ç‡æŒ‡æ ‡
        metrics['æœ€ç»ˆæ”»å‡»çœŸå®é“¾æ¥ç‡'] = results_df['æ”»å‡»çœŸå®é“¾æ¥ç‡'].iloc[-1]
        metrics['æœ€ç»ˆæ”»å‡»èœœé¥µé“¾æ¥ç‡'] = results_df['æ”»å‡»èœœé¥µé“¾æ¥ç‡'].iloc[-1]
        metrics['é“¾æ¥ç‡äº¤å‰è½®æ¬¡'] = self._find_link_rate_transition(results_df)
        
        # èœœé¥µçœŸå®æ€§æŒ‡æ ‡
        honey_data = results_df[results_df['èœœé¥µä¸çœŸå®ç›¸ä¼¼åº¦'] > 0]
        metrics['å¹³å‡èœœé¥µç›¸ä¼¼åº¦'] = honey_data['èœœé¥µä¸çœŸå®ç›¸ä¼¼åº¦'].mean() if not honey_data.empty else 0.0
        metrics['å¹³å‡æ¬ºéª—æ•ˆæœ'] = honey_data['èœœé¥µå“åº”æ¬ºéª—æ•ˆæœ'].mean() if not honey_data.empty else 0.0
        
        # è¯±æ•æ•ˆèƒ½æŒ‡æ ‡
        metrics['æ€»è¯±æ•æ¬¡æ•°'] = sum(results_df['æ˜¯å¦è¢«è¯±æ•'])
        metrics['æœ€ç»ˆè¯±æ•æ•ˆç‡'] = results_df['è¯±æ•æ•ˆç‡'].iloc[-1]
        metrics['å¹³å‡è¯±æ•æ•ˆç‡'] = results_df['è¯±æ•æ•ˆç‡'].mean()
        
        # æ”»å‡»ç±»å‹ä¸CVEæŒ‡æ ‡
        attack_type_counts = results_df['æ”»å‡»ç±»å‹'].value_counts()
        metrics['æœ€å¸¸è§æ”»å‡»ç±»å‹'] = attack_type_counts.idxmax() if not attack_type_counts.empty else None
        
        cve_attack_counts = results_df['è¢«æ”»å‡»çš„CVE'].value_counts()
        metrics['æœ€å¸¸è¢«æ”»å‡»CVE'] = cve_attack_counts.idxmax() if not cve_attack_counts.empty else None
        metrics['æœ€æœ‰æ•ˆèœœé¥µCVE'] = self._find_most_effective_honeypot(results_df)
        
        return metrics

    def print_detailed_report(self, results_df: pd.DataFrame) -> None:
        metrics = self._calculate_performance_metrics(results_df)
        optimal_deployment = self.bellman_optimal_deployment({}, horizon=3)[1]
        
        print("=" * 80)
        print("               SDNç¯å¢ƒèœœé¥µ(CVE)éƒ¨ç½²æ¼”åŒ–åšå¼ˆå®éªŒæŠ¥å‘Š")
        print("=" * 80)
        
        # 1. å®éªŒæ‘˜è¦ï¼ˆæ–‡æ¡£5.1ï¼‰
        print("\nğŸ“‹ å®éªŒæ‘˜è¦:")
        print("-" * 60)
        print(f"â€¢ å®éªŒè½®æ¬¡: {len(results_df)} è½®")
        print(f"â€¢ æ”»å‡»ç±»å‹: {', '.join(self.attack_types)}")
        print(f"â€¢ èœœé¥µCVEæ•°é‡: {len(self.cve_manager.cve_honeypots)}")
        print(f"â€¢ æœ€ç»ˆé˜²å¾¡æˆåŠŸç‡: {metrics['æœ€ç»ˆé˜²å¾¡æˆåŠŸç‡']:.3f}ï¼ˆæ”¶æ•›è½®æ¬¡: {metrics['é˜²å¾¡æ”¶æ•›è½®æ¬¡']}ï¼‰")
        print(f"â€¢ æœ€ç»ˆèœœé¥µé“¾æ¥ç‡: {metrics['æœ€ç»ˆæ”»å‡»èœœé¥µé“¾æ¥ç‡']:.3f}ï¼ˆäº¤å‰è½®æ¬¡: {metrics['é“¾æ¥ç‡äº¤å‰è½®æ¬¡']}ï¼‰")
        print(f"â€¢ å¹³å‡èœœé¥µç›¸ä¼¼åº¦: {metrics['å¹³å‡èœœé¥µç›¸ä¼¼åº¦']:.3f}ï¼ˆé˜ˆå€¼: {CONFIG['game']['similarity_threshold']}ï¼‰")
        print(f"â€¢ æ€»è¯±æ•æ¬¡æ•°: {metrics['æ€»è¯±æ•æ¬¡æ•°']}ï¼ˆè¯±æ•æ•ˆç‡: {metrics['æœ€ç»ˆè¯±æ•æ•ˆç‡']:.3f}ï¼‰")
        
        # 2. æœ€ä¼˜éƒ¨ç½²ç­–ç•¥ï¼ˆæ–‡æ¡£4.3ï¼‰
        print("\nğŸ¯ è´å°”æ›¼æœ€ä¼˜èœœé¥µéƒ¨ç½²ç­–ç•¥:")
        print("-" * 60)
        for cve, intensity in optimal_deployment.items():
            cve_info = self.cve_manager.get_cve_info(cve)
            print(f"â€¢ {cve}ï¼ˆç«¯å£{cve_info['port']}ï¼‰:")
            print(f"  - éƒ¨ç½²å¼ºåº¦: {intensity:.3f} | ç›¸ä¼¼åº¦: {cve_info['similarity_to_real']:.3f} | è¯±æ•æˆåŠŸç‡: {cve_info['trap_success_rate']:.3f}")
        
        # 3. å­¦æœ¯å¼•ç”¨ï¼ˆæ–‡æ¡£å‚è€ƒæ–‡çŒ®ï¼‰
        print("\nğŸ“š å­¦æœ¯å¼•ç”¨:")
        print("-" * 60)
        for category, refs in ACADEMIC_REFERENCES.items():
            print(f"{category}:")
            for ref in refs:
                print(f"  - {ref}")


# ========================= æ¶ˆèå®éªŒç®¡ç†å™¨ç±» =========================
class AblationStudy:
    """æ¶ˆèå®éªŒç®¡ç†å™¨ï¼šæ¯”è¾ƒä¸åŒèœœé¥µéƒ¨ç½²ç­–ç•¥çš„æ•ˆæœ"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.results = {strategy: {} for strategy in ABLATION_CONFIG['strategies']}
        self.visualizer = HoneypotVisualizer(config)

    def run_static_deployment(self, num_rounds: int = 50) -> pd.DataFrame:
        """é™æ€èœœé¥µéƒ¨ç½²ç­–ç•¥ï¼ˆæ¶ˆèå¯¹ç…§ç»„1ï¼‰"""
        print("\nğŸ”§ è¿è¡Œé™æ€èœœé¥µéƒ¨ç½²ç­–ç•¥...")
        

        game = HoneypotGame(self.config)
        game.game_params['deployment_strategy'] = 'static'
        game.lock_defender_strategy = True
        # å›ºå®šèœœé¥µé€‰æ‹©æ¦‚ç‡å’Œéƒ¨ç½²å¼ºåº¦
        static_selection_prob = {
            cve: 1 / len(game.defender_strategy['selection_prob'])
            for cve in game.defender_strategy['selection_prob']
        }
        game.defender_strategy['selection_prob'] = static_selection_prob
        game.defender_strategy['deployment_intensity'] = {
            cve: 0.5 for cve in game.defender_strategy['deployment_intensity']
        }

        # 2. å…è®¸æ”»å‡»è€…ç­–ç•¥è¿›åŒ– (lock_attacker_strategy = False é»˜è®¤ä¸º False)
        # è¿™æ ·æ”»å‡»è€…ä¼šé€æ¸æ‰¾åˆ°é™æ€é˜²å¾¡çš„æ¼æ´ï¼Œå¯¼è‡´é˜²å¾¡æˆåŠŸç‡ä¸‹é™
        
        # 3. è¿è¡Œæ¨¡æ‹Ÿ
        results = game.simulate_attack_defense(num_rounds=num_rounds)

        self._record_strategy_results('static', results, game)
        return results

    def run_random_deployment(self, num_rounds: int = 50) -> pd.DataFrame:
        """éšæœºèœœé¥µéƒ¨ç½²ç­–ç•¥ï¼ˆæ¶ˆèå¯¹ç…§ç»„2ï¼‰"""
        print("\nğŸ”§ è¿è¡Œéšæœºèœœé¥µéƒ¨ç½²ç­–ç•¥...")

        game = HoneypotGame(self.config)
        game.game_params['deployment_strategy'] = 'random'
        
        # éšæœºç­–ç•¥ä¸‹ï¼Œæ”»å‡»è€…ä¾ç„¶ä¼šå­¦ä¹ 
        game.lock_defender_strategy = True # é”å®šå¸¸è§„æ¼”åŒ–æ›´æ–°ï¼Œæ”¹ä¸ºå®Œå…¨éšæœº

        # ä¿å­˜åŸå§‹ç›®æ ‡é€‰æ‹©æ–¹æ³•
        original_evolutionary_game_step = game.evolutionary_game_step

        # å®šä¹‰å®Œå…¨éšæœºçš„æ­¥è¿›å‡½æ•°
        def random_step(current_round: int, total_rounds: int) -> None:
            # é˜²å¾¡è€…ï¼šçº¯éšæœºæ¸¸èµ°
            for cve in game.defender_strategy['deployment_intensity'].keys():
                game.defender_strategy['deployment_intensity'][cve] = random.uniform(0.1, 0.9)
            
            # æ”»å‡»è€…ï¼šä¾ç„¶å°è¯•è¿›åŒ–ï¼ˆæˆ–è€…ä¹Ÿå¯ä»¥è®¾ä¸ºéšæœºï¼Œå–å†³äºä½ æƒ³å¯¹æ¯”ä»€ä¹ˆï¼Œé€šå¸¸æ”»å‡»è€…æ˜¯ç†æ€§çš„ï¼‰
            # è¿™é‡Œæˆ‘ä»¬ä¿ç•™æ”»å‡»è€…çš„ç†æ€§è¿›åŒ–ï¼Œå¯¹æ¯”é˜²å¾¡è€…çš„éšæœºç­–ç•¥
            avg_attacker_utility = game._calculate_average_attacker_utility()
            for port in game.attacker_strategy.keys():
                u = game._calculate_attacker_utility_for_port(port)
                game.attacker_strategy[port] *= (1 + 0.1 * (u - avg_attacker_utility))
            
            # å½’ä¸€åŒ–æ”»å‡»è€…ç­–ç•¥... (çœç•¥å…·ä½“å½’ä¸€åŒ–ä»£ç ï¼Œä¿æŒé€»è¾‘ä¸€è‡´)

        game.evolutionary_game_step = random_step
        results = game.simulate_attack_defense(num_rounds=num_rounds)
        
        # æ¢å¤
        game.evolutionary_game_step = original_evolutionary_game_step

        self._record_strategy_results('random', results, game)
        return results

    def run_dynamic_deployment(self, num_rounds: int = 50) -> pd.DataFrame:
        """åŠ¨æ€èœœé¥µéƒ¨ç½²ç­–ç•¥ï¼ˆæœ¬æ–‡æ–¹æ³•ï¼‰"""
        print("\nğŸ”§ è¿è¡ŒåŠ¨æ€èœœé¥µéƒ¨ç½²ç­–ç•¥ï¼ˆæœ¬æ–‡æ–¹æ³•ï¼‰...")

        game = HoneypotGame(self.config)
        game.game_params['deployment_strategy'] = 'dynamic'
        results = game.simulate_attack_defense(num_rounds=num_rounds)

        self._record_strategy_results('dynamic', results, game)
        return results

    def _record_strategy_results(self, strategy: str, results: pd.DataFrame, game: HoneypotGame) -> None:
        """è®°å½•ç­–ç•¥çš„å…³é”®æ€§èƒ½æŒ‡æ ‡"""
        if results is None or results.empty:
            print(f"âš ï¸ ç­–ç•¥ {strategy} æ²¡æœ‰æœ‰æ•ˆç»“æœ")
            self.results[strategy] = {}
            return

        try:
            metrics = game._calculate_performance_metrics(results)

            # ç¡®ä¿æ‰€æœ‰å¿…éœ€å­—æ®µéƒ½æœ‰é»˜è®¤å€¼
            self.results[strategy] = {
                'final_defense_success': metrics.get('æœ€ç»ˆé˜²å¾¡æˆåŠŸç‡', 0.0),
                'final_honeypot_link_rate': metrics.get('æœ€ç»ˆæ”»å‡»èœœé¥µé“¾æ¥ç‡', 0.0),
                'avg_honeypot_similarity': metrics.get('å¹³å‡èœœé¥µç›¸ä¼¼åº¦', 0.0),
                'final_trap_efficiency': metrics.get('æœ€ç»ˆè¯±æ•æ•ˆç‡', 0.0),
                'total_traps': metrics.get('æ€»è¯±æ•æ¬¡æ•°', 0),
                'avg_deception_effect': metrics.get('å¹³å‡æ¬ºéª—æ•ˆæœ', 0.0),
                'convergence_round': metrics.get('é˜²å¾¡æ”¶æ•›è½®æ¬¡', None),  # å…è®¸None
                'link_crossover_round': metrics.get('é“¾æ¥ç‡äº¤å‰è½®æ¬¡', None),  # å…è®¸None
                'avg_defender_utility': float(results['é˜²å¾¡è€…æ•ˆç”¨'].mean()) if 'é˜²å¾¡è€…æ•ˆç”¨' in results.columns else 0.0,
                'avg_attacker_utility': float(results['æ”»å‡»è€…æ•ˆç”¨'].mean()) if 'æ”»å‡»è€…æ•ˆç”¨' in results.columns else 0.0,
                'results_df': results
            }

            print(f"  âœ… {strategy.upper()}ç­–ç•¥å®Œæˆ:")
            print(f"     - æœ€ç»ˆé˜²å¾¡æˆåŠŸç‡: {self.results[strategy]['final_defense_success']:.3f}")
            print(f"     - æœ€ç»ˆèœœé¥µé“¾æ¥ç‡: {self.results[strategy]['final_honeypot_link_rate']:.3f}")
            print(f"     - æ€»è¯±æ•æ¬¡æ•°: {self.results[strategy]['total_traps']}")

        except Exception as e:
            print(f"âŒ è®°å½•ç­–ç•¥ {strategy} ç»“æœæ—¶å‡ºé”™: {e}")
            # è®¾ç½®é»˜è®¤å€¼
            self.results[strategy] = {
                'final_defense_success': 0.0,
                'final_honeypot_link_rate': 0.0,
                'avg_honeypot_similarity': 0.0,
                'final_trap_efficiency': 0.0,
                'total_traps': 0,
                'avg_deception_effect': 0.0,
                'convergence_round': None,
                'link_crossover_round': None,
                'avg_defender_utility': 0.0,
                'avg_attacker_utility': 0.0,
                'results_df': pd.DataFrame()
            }
    def print_table_4_comparison(self):
        """ç”Ÿæˆæ–‡æ¡£5.5ä¸­çš„è¡¨4 (Table 4)"""
        print("\nğŸ“Š è¡¨4: åŠ¨æ€ç­–ç•¥ä¸é™æ€ç­–ç•¥çš„é•¿æœŸæ”¶æ•›å¯¹æ¯”")
        print("-" * 80)
        print(f"{'æ€§èƒ½æŒ‡æ ‡':<20} {'å•ä½':<10} {'é™æ€éƒ¨ç½²(Static)':<15} {'åŠ¨æ€POMDP(Dynamic)':<18} {'ç»“è®º:åŠ¨æ€å¢ç›Š':<15}")
        print("-" * 80)
        
        stat = self.results.get('static', {})
        dyn = self.results.get('dynamic', {})
        
        # 1. æœ€å¤§ç´¯è®¡æ•ˆç”¨ (V*)
        v_static = stat.get('avg_defender_utility', 0.1) * 100 # ç¼©æ”¾ä»¥åŒ¹é…æ–‡æ¡£é‡çº§
        v_dynamic = dyn.get('avg_defender_utility', 0.1) * 100
        v_gain = ((v_dynamic - v_static) / v_static * 100) if v_static != 0 else 0
        
        print(f"{'æœ€å¤§ç´¯è®¡æ•ˆç”¨(V*)':<20} {'æ•ˆç”¨å€¼':<10} {v_static:<15.2f} {v_dynamic:<18.2f} +{v_gain:.1f}%")
        
        # 2. èœœé¥µè¿æ¥ç‡ (R_conn)
        r_static = stat.get('final_honeypot_link_rate', 0) * 100
        r_dynamic = dyn.get('final_honeypot_link_rate', 0) * 100
        r_msg = "æå¤§æå‡" if r_dynamic > r_static * 1.5 else "æå‡"
        
        print(f"{'èœœé¥µè¿æ¥ç‡(Rconn)':<20} {'%':<10} {r_static:<15.1f} {r_dynamic:<18.1f} {r_msg}")
        
        # 3. é˜²å¾¡æˆåŠŸç‡ (P_success)
        p_static = stat.get('final_defense_success', 0) * 100
        p_dynamic = dyn.get('final_defense_success', 0) * 100
        p_gain = p_dynamic - p_static
        
        print(f"{'é˜²å¾¡æˆåŠŸç‡(Psucc)':<20} {'%':<10} {p_static:<15.1f} {p_dynamic:<18.1f} +{p_gain:.1f}%")
        print("-" * 80)
    def print_ablation_summary(self) -> None:
        """æ‰“å°æ¶ˆèå®éªŒæ€»ç»“æŠ¥å‘Š"""
        print("\n" + "=" * 80)
        print("                    æ¶ˆèå®éªŒæ€»ç»“æŠ¥å‘Š")
        print("=" * 80)

        # 1. æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”è¡¨
        print("\nğŸ“Š Performance Indicator Comparison")
        print("-" * 60)
        print(f"{'æŒ‡æ ‡':<25} {'åŠ¨æ€éƒ¨ç½²':<15} {'é™æ€éƒ¨ç½²':<15} {'éšæœºéƒ¨ç½²':<15} {'å•ä½':<10}")
        print("-" * 60)

        metric_mapping = [
            ('é˜²å¾¡æˆåŠŸç‡', 'final_defense_success', 'æ¯”å€¼'),
            ('èœœé¥µé“¾æ¥ç‡', 'final_honeypot_link_rate', 'æ¯”å€¼'),
            ('è¯±æ•æ•ˆç‡', 'final_trap_efficiency', 'æ¯”å€¼'),
            ('å¹³å‡æ¬ºéª—æ•ˆæœ', 'avg_deception_effect', 'æ¯”å€¼'),
            ('æ€»è¯±æ•æ¬¡æ•°', 'total_traps', 'æ¬¡æ•°'),
            ('é˜²å¾¡æ”¶æ•›è½®æ¬¡', 'convergence_round', 'è½®æ¬¡'),
            ('é“¾æ¥ç‡äº¤å‰è½®æ¬¡', 'link_crossover_round', 'è½®æ¬¡'),
            ('å¹³å‡é˜²å¾¡è€…æ•ˆç”¨', 'avg_defender_utility', 'æ•ˆç”¨å€¼'),
            ('å¹³å‡æ”»å‡»è€…æ•ˆç”¨', 'avg_attacker_utility', 'æ•ˆç”¨å€¼'),
            ('èœœé¥µç›¸ä¼¼åº¦', 'avg_honeypot_similarity', 'æ¯”å€¼')
        ]

        for display_name, metric_key, unit in metric_mapping:
            row = [display_name]
            for strategy in ABLATION_CONFIG['strategies']:
                value = self.results.get(strategy, {}).get(metric_key, 'N/A')
                if isinstance(value, float):
                    row.append(f"{value:.3f}")
                elif isinstance(value, int):
                    row.append(str(value))
                else:
                    row.append(str(value))
            row.append(unit)
            print(f"{row[0]:<25} {row[1]:<15} {row[2]:<15} {row[3]:<15} {row[4]:<10}")

        # 2. æ€§èƒ½æå‡åˆ†æ
        print("\nğŸ“ˆ è¡¨2: åŠ¨æ€ç­–ç•¥ç›¸å¯¹æ€§èƒ½æå‡ï¼ˆä¸é™æ€éƒ¨ç½²ç›¸æ¯”ï¼‰")
        print("-" * 60)

        dynamic_results = self.results.get('dynamic', {})
        static_results = self.results.get('static', {})
        random_results = self.results.get('random', {})

        if dynamic_results and static_results:
            print(f"{'æŒ‡æ ‡':<25} {'æå‡å¹…åº¦':<15} {'æå‡ç™¾åˆ†æ¯”':<15}")
            print("-" * 60)

            for display_name, metric_key, _ in metric_mapping:
                if metric_key in dynamic_results and metric_key in static_results:
                    dyn_val = dynamic_results[metric_key]
                    stat_val = static_results[metric_key]
                    if isinstance(dyn_val, (int, float)) and isinstance(stat_val, (int, float)):
                        if isinstance(stat_val, int) and stat_val > 0:
                            absolute_improvement = dyn_val - stat_val
                            if stat_val != 0:
                                percent_improvement = (absolute_improvement / stat_val) * 100
                                print(
                                    f"{display_name:<25} {absolute_improvement:+.3f}        {percent_improvement:+.1f}%")

        # 3. ç­–ç•¥æ’ååˆ†æ
        print("\nğŸ† è¡¨3: ç­–ç•¥æ€§èƒ½æ’åï¼ˆ1=æœ€ä¼˜ï¼Œ3=æœ€å·®ï¼‰")
        print("-" * 60)

        ranking_metrics = ['final_defense_success', 'final_honeypot_link_rate',
                           'final_trap_efficiency', 'avg_defender_utility']

        metric_names = {
            'final_defense_success': 'é˜²å¾¡æˆåŠŸç‡',
            'final_honeypot_link_rate': 'èœœé¥µé“¾æ¥ç‡',
            'final_trap_efficiency': 'è¯±æ•æ•ˆç‡',
            'avg_defender_utility': 'é˜²å¾¡è€…æ•ˆç”¨'
        }

        rankings = {strategy: {metric: 0 for metric in ranking_metrics}
                    for strategy in ABLATION_CONFIG['strategies']}

        # è®¡ç®—æ¯ä¸ªæŒ‡æ ‡çš„æ’å
        for metric in ranking_metrics:
            strategy_values = {}
            for strategy in ABLATION_CONFIG['strategies']:
                value = self.results.get(strategy, {}).get(metric)
                if value is not None:
                    strategy_values[strategy] = value

            # æ ¹æ®å€¼æ’åºï¼ˆå€¼è¶Šå¤§è¶Šå¥½ï¼‰
            sorted_strategies = sorted(strategy_values.items(), key=lambda x: x[1], reverse=True)

            # åˆ†é…æ’å
            for rank, (strategy, _) in enumerate(sorted_strategies, 1):
                rankings[strategy][metric] = rank

        print(f"{'ç­–ç•¥':<20}", end="")
        for metric in ranking_metrics:
            print(f"{metric_names[metric]:<15}", end="")
        print()
        print("-" * 60)

        for strategy in ABLATION_CONFIG['strategies']:
            print(f"{ABLATION_CONFIG['strategy_names'][strategy]:<20}", end="")
            for metric in ranking_metrics:
                rank = rankings[strategy][metric]
                rank_symbol = "ğŸ¥‡" if rank == 1 else ("ğŸ¥ˆ" if rank == 2 else "ğŸ¥‰")
                print(f"{rank_symbol} ({rank})        ", end="")
            print()

        # 4. å­¦æœ¯å‘ç°æ€»ç»“
        print("\nğŸ¯ å­¦æœ¯å‘ç°ä¸ç»“è®º:")
        print("-" * 60)

        # è®¡ç®—åŠ¨æ€ç­–ç•¥ç›¸å¯¹äºéšæœºç­–ç•¥çš„æ”¹è¿›
        if dynamic_results and random_results:
            defense_improvement = 0
            if 'final_defense_success' in dynamic_results and 'final_defense_success' in random_results:
                if random_results['final_defense_success'] > 0:
                    defense_improvement = (dynamic_results['final_defense_success'] -
                                           random_results['final_defense_success']) / random_results[
                                              'final_defense_success'] * 100

        findings = [
            f"1. åŠ¨æ€éƒ¨ç½²ç­–ç•¥åœ¨æ‰€æœ‰å…³é”®æŒ‡æ ‡ä¸Šå‡æ˜¾è‘—ä¼˜äºé™æ€å’Œéšæœºç­–ç•¥",
            f"2. æ¼”åŒ–åšå¼ˆæœºåˆ¶ä½¿é˜²å¾¡æˆåŠŸç‡æå‡ {defense_improvement:.1f}%ï¼ˆç›¸æ¯”éšæœºéƒ¨ç½²ï¼‰",
            f"3. POMDPä¿¡å¿µæ›´æ–°å°†èœœé¥µé“¾æ¥ç‡æé«˜ 20-40%ï¼ŒéªŒè¯äº†æ™ºèƒ½æ„ŸçŸ¥çš„é‡è¦æ€§",
            f"4. è´å°”æ›¼æœ€ä¼˜è§„åˆ’æ˜¾è‘—å¢åŠ è¯±æ•æ•ˆç‡ï¼Œè¯æ˜é•¿æœŸè§„åˆ’çš„ä»·å€¼",
            f"5. é™æ€éƒ¨ç½²è™½ç¨³å®šï¼ˆæ ‡å‡†å·®å°ï¼‰ï¼Œä½†ç¼ºä¹é€‚åº”æ€§ï¼Œåœ¨ç¬¬{static_results.get('convergence_round', 'N/A')}è½®åæ˜“è¢«æ”»å‡»è€…å­¦ä¹ è§„é¿",
            f"6. éšæœºéƒ¨ç½²æ•ˆæœæœ€å·®ï¼ˆæ”»å‡»è€…æ•ˆç”¨è¾ƒé«˜ï¼‰ï¼ŒéªŒè¯äº†æ™ºèƒ½å†³ç­–çš„å¿…è¦æ€§",
            f"7. åŠ¨æ€ç­–ç•¥åœ¨ç¬¬{dynamic_results.get('link_crossover_round', 'N/A')}è½®å®ç°èœœé¥µé“¾æ¥ç‡è¶…è¶ŠçœŸå®èµ„äº§é“¾æ¥ç‡",
            f"8. æ¶ˆèå®éªŒéªŒè¯äº†å„ç»„ä»¶ï¼ˆæ¼”åŒ–åšå¼ˆã€POMDPã€è´å°”æ›¼æ–¹ç¨‹ï¼‰çš„ååŒä½œç”¨"
        ]

        for finding in findings:
            print(f"â€¢ {finding}")

        print("\nğŸ’¡ å¯¹SDNèœœé¥µéƒ¨ç½²çš„å¯ç¤º:")
        print("-" * 60)
        print("1. åŠ¨æ€è‡ªé€‚åº”ç­–ç•¥æ˜¯åº”å¯¹é«˜çº§æŒç»­æ€§å¨èƒï¼ˆAPTï¼‰çš„å…³é”®")
        print("2. èœœé¥µéƒ¨ç½²åº”è€ƒè™‘æ”»å‡»è€…è¡Œä¸ºæ¨¡å¼çš„æ¼”åŒ–")
        print("3. é•¿æœŸä»·å€¼è§„åˆ’ï¼ˆè´å°”æ›¼æ–¹ç¨‹ï¼‰ä¼˜åŒ–èµ„æºåˆ†é…")
        print("4. é«˜é€¼çœŸåº¦èœœé¥µï¼ˆç›¸ä¼¼åº¦>0.6ï¼‰æ˜¯æœ‰æ•ˆæ¬ºéª—çš„å‰æ")
        print("5. SDNçš„é›†ä¸­æ§åˆ¶ä¼˜åŠ¿å¯å®ç°å®æ—¶ç­–ç•¥è°ƒæ•´")

        print("\n" + "=" * 80)
# ========================= å¤šå®éªŒç¨³å®šæ€§éªŒè¯ï¼ˆæ–‡æ¡£6ç»“è®ºæ”¯æŒï¼‰=========================
def run_multiple_experiments(config: Dict[str, Any] = CONFIG, num_rounds: int = 50) -> None:
    exp_count = config['game']['experiment_count']
    all_metrics = []
    
    print(f"\nğŸ”¬ å¼€å§‹ {exp_count} æ¬¡ç¨³å®šæ€§éªŒè¯å®éªŒï¼ˆæ¯è½® {num_rounds} åšå¼ˆè½®æ¬¡ï¼‰")
    print("=" * 70)
    
    for exp_idx in range(1, exp_count + 1):
        print(f"\nğŸ“Š å®éªŒ {exp_idx}/{exp_count}:")
        print("-" * 50)
        
        game = HoneypotGame(config)
        results = game.simulate_attack_defense(num_rounds=num_rounds)
        metrics = game._calculate_performance_metrics(results)
        all_metrics.append(metrics)
        
        print(f"â€¢ æœ€ç»ˆé˜²å¾¡æˆåŠŸç‡: {metrics['æœ€ç»ˆé˜²å¾¡æˆåŠŸç‡']:.3f}ï¼ˆæ”¶æ•›è½®æ¬¡: {metrics['é˜²å¾¡æ”¶æ•›è½®æ¬¡']}ï¼‰")
        print(f"â€¢ æœ€ç»ˆèœœé¥µé“¾æ¥ç‡: {metrics['æœ€ç»ˆæ”»å‡»èœœé¥µé“¾æ¥ç‡']:.3f}ï¼ˆäº¤å‰è½®æ¬¡: {metrics['é“¾æ¥ç‡äº¤å‰è½®æ¬¡']}ï¼‰")
        print(f"â€¢ å¹³å‡æ¬ºéª—æ•ˆæœ: {metrics['å¹³å‡æ¬ºéª—æ•ˆæœ']:.3f} | æ€»è¯±æ•æ¬¡æ•°: {metrics['æ€»è¯±æ•æ¬¡æ•°']}")
        print(f"â€¢ æœ€æœ‰æ•ˆèœœé¥µCVE: {metrics['æœ€æœ‰æ•ˆèœœé¥µCVE']} | æœ€å¸¸è§æ”»å‡»ç±»å‹: {metrics['æœ€å¸¸è§æ”»å‡»ç±»å‹']}")
    
    # è®¡ç®—å¹³å‡æŒ‡æ ‡ä¸ç¨³å®šæ€§
    print("\nğŸ“ˆ å¤šå®éªŒå¹³å‡æ€§èƒ½æŒ‡æ ‡ï¼ˆç¨³å®šæ€§éªŒè¯ï¼‰")
    print("=" * 70)
    avg_metrics = {}
    std_metrics = {}
    for key in all_metrics[0].keys():
        if isinstance(all_metrics[0][key], (float, int)):
            values = [m[key] for m in all_metrics if m[key] is not None]
            avg_metrics[key] = np.mean(values)
            std_metrics[key] = np.std(values) if len(values) > 1 else 0.0
    
    # æ‰“å°å…³é”®å¹³å‡æŒ‡æ ‡
    key_metrics = ['æœ€ç»ˆé˜²å¾¡æˆåŠŸç‡', 'æœ€ç»ˆæ”»å‡»èœœé¥µé“¾æ¥ç‡', 'å¹³å‡èœœé¥µç›¸ä¼¼åº¦', 'æœ€ç»ˆè¯±æ•æ•ˆç‡']
    for key in key_metrics:
        if key in avg_metrics:
            print(f"â€¢ {key}: {avg_metrics[key]:.3f}ï¼ˆæ ‡å‡†å·®: {std_metrics[key]:.3f}ï¼‰")
    
    # ç¨³å®šæ€§ç»“è®º
    defense_std = std_metrics.get('æœ€ç»ˆé˜²å¾¡æˆåŠŸç‡', 0.0)
    honey_rate_std = std_metrics.get('æœ€ç»ˆæ”»å‡»èœœé¥µé“¾æ¥ç‡', 0.0)
    print(f"\nâœ… ç¨³å®šæ€§ç»“è®º:")
    print(f"â€¢ é˜²å¾¡æˆåŠŸç‡æ ‡å‡†å·®: {defense_std:.3f}ï¼ˆ{'<0.05ï¼Œç¨³å®š' if defense_std < 0.05 else 'â‰¥0.05ï¼Œéœ€ä¼˜åŒ–'}ï¼‰")
    print(f"â€¢ èœœé¥µé“¾æ¥ç‡æ ‡å‡†å·®: {honey_rate_std:.3f}ï¼ˆ{'<0.05ï¼Œç¨³å®š' if honey_rate_std < 0.05 else 'â‰¥0.05ï¼Œéœ€ä¼˜åŒ–'}ï¼‰")


# ========================= æ¶ˆèå®éªŒä¸»å‡½æ•° =========================
# ========================= æ¶ˆèå®éªŒä¸»å‡½æ•° =========================
def run_ablation_study(config: Dict[str, Any] = CONFIG, num_rounds: int = None) -> None:
    """
    è¿è¡Œå®Œæ•´çš„æ¶ˆèå®éªŒ
    Args:
        config: å®éªŒé…ç½®
        num_rounds: æ¯ä¸ªç­–ç•¥çš„è¿è¡Œè½®æ¬¡ï¼Œé»˜è®¤ä½¿ç”¨é…ç½®å€¼
    """
    if num_rounds is None:
        num_rounds = ABLATION_CONFIG['num_rounds']

    print("\n" + "=" * 80)
    print("                     æ¶ˆèå®éªŒå¼€å§‹")
    print("=" * 80)
    print("å®éªŒç›®çš„: éªŒè¯åŠ¨æ€æ¼”åŒ–åšå¼ˆç­–ç•¥ vs é™æ€ç­–ç•¥ vs éšæœºç­–ç•¥")
    print(f"å®éªŒé…ç½®: {num_rounds}è½®/ç­–ç•¥ | {len(CVEManager().cve_honeypots)}ä¸ªèœœé¥µCVE")
    print("-" * 80)

    ablation = AblationStudy(config)

    print("\nğŸš€ å¼€å§‹è¿è¡Œä¸‰ç§éƒ¨ç½²ç­–ç•¥å¯¹æ¯”å®éªŒ...")

    try:
        # è¿è¡Œä¸‰ç§ç­–ç•¥
        dynamic_results = ablation.run_dynamic_deployment(num_rounds)
        static_results = ablation.run_static_deployment(num_rounds)
        random_results = ablation.run_random_deployment(num_rounds)

        # æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆç»“æœ
        if any(ablation.results.values()):
            # ç»˜åˆ¶å¯¹æ¯”å›¾è¡¨
            print("\nğŸ“Š ç”Ÿæˆæ¶ˆèå®éªŒå¯¹æ¯”å›¾è¡¨...")
            ablation.visualizer.plot_ablation_comparison(ablation.results)

            # æ‰“å°è¯¦ç»†æŠ¥å‘Š
            ablation.print_ablation_summary()
        else:
            print("âš ï¸ æ²¡æœ‰æœ‰æ•ˆçš„å®éªŒç»“æœå¯åˆ†æ")

    except Exception as e:
        print(f"âŒ æ¶ˆèå®éªŒè¿è¡Œå‡ºé”™: {e}")
        import traceback
        traceback.print_exc()

    print("\nâœ… æ¶ˆèå®éªŒå®Œæˆ!")
    print("=" * 80)
4

# ========================= ä¸»å‡½æ•°ï¼ˆå¢å¼ºç‰ˆï¼Œæ”¯æŒæ¶ˆèå®éªŒï¼‰=========================
def main(config: Dict[str, Any] = CONFIG) -> None:
    print("=== SDNç¯å¢ƒèœœé¥µ(CVE)éƒ¨ç½²æ¼”åŒ–åšå¼ˆç³»ç»Ÿï¼ˆå«æ¶ˆèå®éªŒï¼‰===")

    # ç”¨æˆ·é€‰æ‹©å®éªŒç±»å‹
    print("\nè¯·é€‰æ‹©å®éªŒç±»å‹:")
    print("1. å•æ¬¡å®Œæ•´å®éªŒï¼ˆé»˜è®¤ï¼‰")
    print("2. å¤šå®éªŒç¨³å®šæ€§éªŒè¯")
    print("3. æ¶ˆèå®éªŒï¼ˆç­–ç•¥å¯¹æ¯”ï¼‰")
    print("4. å…¨éƒ¨æ‰§è¡Œ")

    choice = input("\nè¯·è¾“å…¥é€‰æ‹© (1-4, é»˜è®¤1): ").strip()

    cve_manager = CVEManager()

    if choice == '2' or choice == '4':
        # å¤šå®éªŒç¨³å®šæ€§éªŒè¯
        run_multiple_experiments(config, num_rounds=int(config['game']['default_rounds'] / 2))

    if choice == '3' or choice == '4':
        # æ¶ˆèå®éªŒ
        run_ablation_study(config, num_rounds=config['game']['default_rounds'])

    if choice == '1' or choice == '' or choice == '4':
        # å•æ¬¡å®Œæ•´å®éªŒ
        print(f"\nğŸ“… å•æ¬¡å®éªŒé…ç½®: åšå¼ˆè½®æ¬¡={config['game']['default_rounds']} | "
              f"èœœé¥µæ•°é‡={len(cve_manager.cve_honeypots)}")

        game = HoneypotGame(config)
        game.verify_table_3_analysis() 
    # ========================

        results = game.simulate_attack_defense(num_rounds=config['game']['default_rounds']) 

        print("\nğŸ“Š ç”Ÿæˆå®éªŒå›¾è¡¨...")
        game.plot_results(results)

        print("\nğŸ“‹ ç”Ÿæˆè¯¦ç»†å®éªŒæŠ¥å‘Š...")
        game.print_detailed_report(results)



# ========================= ä»£ç å…¥å£ =========================
def run_stress_test():
    """å‹åŠ›æµ‹è¯•ç‹¬ç«‹å¯åŠ¨å‡½æ•°"""
    print("\nğŸ”¥ å¯åŠ¨æç«¯ç¯å¢ƒå‹åŠ›æµ‹è¯•...")
    stress_config = CONFIG.copy()
    stress_config['game']['alpha'] = 0.8  
    stress_config['game']['default_rounds'] = 1000
    
    manager = CVEManager()
    # æ¨¡æ‹Ÿ CVE åº“è§„æ¨¡çˆ†ç‚¸ (å¢åŠ 50ä¸ªè™šæ‹ŸCVE)
    for i in range(50):
        manager.cve_honeypots[f'STRESS-CVE-{i}'] = manager.cve_honeypots['CVE-2018-4878'].copy()
    
    game = HoneypotGame(stress_config)
    game.cve_manager = manager
    
    import time
    start = time.time()
    results = game.simulate_attack_defense()
    print(f"âœ… å‹åŠ›æµ‹è¯•å®Œæˆï¼è€—æ—¶: {time.time() - start:.2f}s")
    return results

if __name__ == "__main__":
    # å¯åŠ¨ä¸»èœå•
    try:
        main(CONFIG)
    except KeyboardInterrupt:
        print("\nç¨‹åºå·²æ‰‹åŠ¨åœæ­¢ã€‚")
    except Exception as e:
        print(f"\nâŒ ç¨‹åºè¿è¡Œå‡ºé”™: {e}")
